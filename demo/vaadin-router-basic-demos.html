<dom-module id="vaadin-router-basic-demos">
  <template>
    <style include="vaadin-component-demo-shared-styles">
      :host {
        display: block;
      }
    </style>

    <h3>The <code>Router</code> class</h3>
    <p>The <code>Router</code> class can be imported from the <code>@vaadin/router</code>
      module in the browsers that support ES modules:
    </p>
    <pre><code>&lt;script type="module"&gt;
  import {Router} from '@vaadin/router';
&lt;/script&gt;</code></pre>
    <p>For the browsers that do not support ES modules, the  <code>Router</code>
      class is exposed as a member of the <code>Vaadin</code> namespace after
      the vaadin-router UMD bundle is loaded:
    </p>
    <pre><code>&lt;script src="bower_components/vaadin-router/vaadin-router.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
  var Router = Vaadin.Router;
&lt;/script&gt;</code></pre>

    <h3>Getting Started</h3>
    <p>Vaadin.Router automatically listens to navigation events and
      asynchronously renders a matching Web Component into the given DOM node
      (a.k.a. the router <em>outlet</em>). By default, navigation events are
      triggered by <code>popstate</code> events on the <code>window</code>, and
      by <code>click</code> events on <code>&lt;a&gt;</code> elements on the
      page (see <a href="#vaadin-router-navigation-trigger-demos">Navigation
      Triggers</a> for details).</p>
    <p>The routes config maps URL paths to Web Components. Vaadin.Router goes
      through the routes until it finds the first match, creates an instance
      of the route component, and inserts it into the router outlet (replacing
      any pre-existing outlet content). For details on the route path syntax
      see the <a href="#vaadin-router-route-parameters-demos">Router Parameters
      </a> demos.</p>
    <p>Route components can be any Web Components regardless of how they are
      built: vanilla JavaScript, Polymer, Stencil, SkateJS, Angular, Vue, etc</p>
    <vaadin-demo-snippet id="vaadin-router-basic-demo-1" iframe-src="iframe.html">
      <template preserve-content>
        <a href="/">Home</a>
        <a href="/users">Users</a>
        <div id="outlet"></div>
        <script type="module">
          // import {Router} from '@vaadin/router';
          const {Router} = window.Vaadin;

          const router = new Router(document.getElementById('outlet'));
          router.setRoutes([
            {path: '/', component: 'x-home-view'},
            {path: '/users', component: 'x-user-list'},
            {path: '/users/:user', component: 'x-user-profile'},
          ]);
        </script>
      </template>
    </vaadin-demo-snippet>

    <h3>Child Routes</h3>
    <p>Each route can have child routes, which makes it easier to group related
      routes together under a common parent. This is optional, i.e. the same
      routes config can be expressed as a flat list, or as a parent-childern
      tree. The routes config in the example below is effectively the same as in
      the example above.</p>
    <p>The leading <code>'/'</code> in child route paths is optional&mdash;they
      are always relative to the path of the parent route.</p>
    <vaadin-demo-snippet id="vaadin-router-basic-demo-2" iframe-src="iframe.html">
      <template preserve-content>
        <a href="/">Home</a>
        <a href="/users">All Users</a>
        <a href="/users/kim">Kim</a>
        <div id="outlet"></div>
        <script type="module">
          // import {Router} from '@vaadin/router';
          const {Router} = window.Vaadin;

          const router = new Router(document.getElementById('outlet'));
          router.setRoutes([
            {path: '/', component: 'x-home-view'},
            {path: '/users',
              children: [
                {path: '/', component: 'x-user-list'},
                {path: '/:user', component: 'x-user-profile'}
              ]
            },
          ]);
        </script>
      </template>
    </vaadin-demo-snippet>

    <h3>Ambiguous Matches</h3>
    <p>
      Route matching rules can be ambiguous, so that several routes would match
      the same path. In that case, the order in which the routes are defined is
      important. The first route matching the path gets rendered (starting from
      the top of the list / root of the tree).</p>
    <p>
      The default route matching is <strong>exact</strong>, i.e. a
      <code>'/user'</code> route (if it does not have children) matches only the
      <code>'/user'</code> path, but not <code>'/users'</code> nor
      <code>'/user/42'</code>. Trailing slashes are not significant in paths,
      but are significant in routes, i.e. a <code>'/user'</code> route matches
      both <code>'/user'</code> the <code>'/user/'</code>, but a
      <code>'/user/'</code> route matches only the <code>'/user/'</code> path.
    </p>
    <p><strong>Prefix</strong> matching is used for routes with children, or if
      the route explicitly indicates that trailing content is expected (e.g.
      a <code>'/users/(*.)'</code> route matches any path starting with
      <code>'/users/'</code>).
    </p>
    <p>
      Always place more specific routes before less specific:
      <ul>
        <li><code>{path: '/user/new', ...}</code> - matches only
          <code>'/user/new'</code></li>
        <li><code>{path: '/user/:user', ...}</code> - matches
          <code>'/user/42'</code>, but not <code>'/user/42/edit'</code></li>
        <li><code>{path: '/user/(.*)', ...}</code> - matches anything starting
          with <code>'/user/'</code></li>
      </ul>
    </p>
    <vaadin-demo-snippet id="vaadin-router-basic-demo-3" iframe-src="iframe.html">
      <template preserve-content>
        <a href="/">Home</a>
        <a href="/users">All Users</a>
        <a href="/kim">Kim</a>
        <div id="outlet"></div>
        <script type="module">
          // import {Router} from '@vaadin/router';
          const {Router} = window.Vaadin;

          const router = new Router(document.getElementById('outlet'));
          router.setRoutes([
            {path: '/', component: 'x-home-view'},
            {path: '/users', component: 'x-user-list'},
            {path: '/:user', component: 'x-user-profile'},
          ]);
        </script>
      </template>
    </vaadin-demo-snippet>

    <h3>Fallback Routes (404)</h3>
    <p>If Vaadin.Router does not find a matching route, the promise returned
      from the <code>render()</code> method gets rejected, and any content in
      the router outlet is removed. In order to show a user-friendly 'page not
      found' view, a fallback route with a wildcard <code>'(.*)'</code> path can
      be added to the <strong>end</strong> of the routes list.</p>
    <p>There can be different fallbacks for different route prefixes, but since
      the route resolution is based on the first match, the fallback route
      should always be <strong>after</strong> other alternatives.</p>
    <p>The path that leads to the fallback route is available to the route
      component via the <code>route.pathname</code> property.</p>
    <vaadin-demo-snippet id="vaadin-router-basic-demo-4" iframe-src="iframe.html">
      <template preserve-content>
        <a href="/">Home</a>
        <a href="/users">All Users</a>
        <a href="/users/kim">Kim</a>
        <a href="/about">About</a>
        <div id="outlet"></div>
        <script type="module">
          // import {Router} from '@vaadin/router';
          const {Router} = window.Vaadin;

          const router = new Router(document.getElementById('outlet'));
          router.setRoutes([
            {path: '/', component: 'x-home-view'},
            {path: '/users', component: 'x-user-list'},
            {path: '/users/(.*)', component: 'x-user-not-found-view'},
            {path: '(.*)', component: 'x-not-found-view'},
          ]);
        </script>
      </template>
    </vaadin-demo-snippet>
  </template>
  <script>
    class VaadinRouterBasicDemos extends DemoReadyEventEmitter(ElementDemo(Polymer.Element)) {
      static get is() {
        return 'vaadin-router-basic-demos';
      }
    }
    customElements.define(VaadinRouterBasicDemos.is, VaadinRouterBasicDemos);
  </script>
</dom-module>
