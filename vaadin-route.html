<!--
@license
Copyright (c) 2018 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../polymer/lib/mixins/properties-mixin.html">
<link rel="import" href="vaadin-router.html">

<script>
  (function() {
    const RouterElement = Vaadin.RouterElement;

    /**
     * `<vaadin-route>` is a Web Component that defines a single route for the
     * `<vaadin-router>` component.
     *
     * ```
     * <vaadin-route path="/users/:user" component="x-user-profile"></vaadin-route>
     * ```
     * or with an inline template
     * ```
     * <vaadin-route path="/users/:user">
     *   <tempalte>
     *     View [[user]]'s profile
     *   </template>
     * </vaadin-route>
     * ```
     *
     * @polymer
     * @customElement
     * @memberof Vaadin
     * @appliesMixin Vaadin.RouterMixin
     * @appliesMixin Polymer.PropertiesMixin
     */
    class RouteElement extends Polymer.PropertiesMixin(HTMLElement) {
      static get is() {
        return 'vaadin-route';
      }

      static get properties() {
        return {
          /** Defines the path served by this route */
          path: String,

          /** Defines the component rendered for this route */
          component: String
        };
      }

      connectedCallback() {
        super.connectedCallback();

        const isChildOfRouter = this.parentElement instanceof Vaadin.RouterElement;
        const isChildOfRoute = this.parentElement instanceof RouteElement;
        if (!isChildOfRouter && !isChildOfRoute) {
          const message = '<vaadin-route> should be a direct child either of a '
            + '<vaadin-router> element or of another <vaadin-route>, but this '
            + 'one is not:';
          console.error(message, this);
          throw new Error(message);
        }

        this.__route = {
          path: this.path,
          children: null,
          action: this.action.bind(this),
        };
        this.__router = isChildOfRouter ? this.parentElement : this.parentElement.__router;
        this.parentElement.addRoute(this.__route);

        this.__inlineTemplate = this.querySelector('template');
        this.__observer = new MutationObserver(() => {
          this.__inlineTemplate = this.querySelector('template');
        });
        this.__observer.observe(this, { childList: true });
      }

      disconnectedCallback() {
        this.__observer.disconnect();
        this.parentElement.removeRoute(this.__route);
        super.disconnectedCallback();
      }

      addRoute(childRoute) {
        RouterElement.ensureRoute(childRoute);

        this.__route.children = this.__route.children || [];
        this.__route.children.push(childRoute);
        this.__router.resolve();
      }

      removeRoute(childRoute) {
        RouterElement.ensureRoute(childRoute);

        if (!this.__route.children) {
          return;
        }

        const index = this.__route.children.indexOf(childRoute);
        if (index > -1) {
          this.__route.children.splice(index, 1);
        }
        this.__router.resolve();
      }

      action(context) {
        let element;
        if (this.component) {
          element = RouterElement.renderComponent(this.component, context);
        } else if (this.__inlineTemplate) {
          element = this.__renderTemplate(context);
        }

        return element;
      }

      __renderTemplate(context) {
        if (Polymer && Polymer.Templatize) {
          // if Polymer.Templatize is available use it to enable data binding
          const TemplateClass = Polymer.Templatize.templatize(this.__inlineTemplate);
          const instance = new TemplateClass(context.params);
          return document.importNode(instance.root, true);
        } else {
          // otherwise just stamp the template content
          return document.importNode(this.__inlineTemplate.content, true);
        }
      }

      /**
       * (override of `Polymer.PropertiesChanged._propertiesChanged`)
       * 
       * Callback called when any properties with accessors created via
       * `_createPropertyAccessor` have been set.
       *
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {!Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {!Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @return {void}
       * @protected
       */
      _propertiesChanged(currentProps, changedProps, oldProps) {
        super._propertiesChanged(currentProps, changedProps, oldProps);

        if ('path' in changedProps && this.__router) {
          this.__route.path = changedProps.path;
          this.__router.resove();
        }
      }
    }

    customElements.define(RouteElement.is, RouteElement);

    /**
     * @namespace Vaadin
     */
    window.Vaadin = window.Vaadin || {};
    Vaadin.RouteElement = RouteElement;
  })();
</script>