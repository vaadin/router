import path from 'path';
import resolve from 'rollup-plugin-node-resolve';
import commonjs from 'rollup-plugin-commonjs';
import pkg from './package.json';

const commonConfig = {
  input: 'index.js',
  plugins: [
    resolve(), // so Rollup can find the 'path-to-regexp' NPM module
    commonjs(), // so Rollup can import 'path-to-regexp' as an ES6 module even though it exports in CommonJS
  ]
};

const sourceFiles = new Map([
  ['path-to-regexp.js', 'pathToRegexp'],
  ['matchPath.js', 'matchPath'],
  ['matchRoute.js', 'matchRoute'],
  ['resolver.js', 'Resolver'],
  ['generateUrls.js', 'generateUrls'],
]);
const coverageBundles = Array.from(sourceFiles.entries()).map(([file, name]) => {
  return {
    input: `src/resolver/${file}`,
    external: (id, parent, isResolved) => {
      return !!parent && sourceFiles.has(path.basename(id));
    },
    output: {
      format: 'iife',
      file: `dist/test-iife/resolver/${file}`,
      banner: '/* This file is automatically generated by `npm run build` */',
      name: `VaadinTestNamespace.${name}`,
      globals: (id) => {
        const name = sourceFiles.get(path.basename(id));
        return name ? `VaadinTestNamespace.${name}` : id;
      },
    },
    plugins: commonConfig.plugins,
  };
});

export default [
  // browser-friendly UMD build with all dependencies bundled-in
  Object.assign({}, commonConfig, {
    output: {
      format: 'umd',
      file: pkg.browser,
      name: 'Vaadin.Router',
      sourcemap: true,
    }
  }),

  // ES module build with all dependencies bundled-in
  // This is a tradeoff between ease of use (always) and size-efficiency (in some
  // cases): The 'path-to-regexp' dependency is not compatible with the ES module
  // imports and needs to be converted into a ES module for this module to be usable.
  // Bundling it in at this point removes the need to do it later, so this module
  // can be imported 'as is'. The size inefficiency could be an issue if some other
  // part of the app also has a dependency on 'path-to-regexp'. In that case, it would
  // need to include its own copy of the dep (no deduplication).
  Object.assign({}, commonConfig, {
    output: {
      format: 'es',
      file: pkg.module,
      sourcemap: true,
    }
  }),

  // CommonJS (for Node) build
  Object.assign({}, commonConfig, {
    external: ['path-to-regexp'],
    output: {
      format: 'cjs',
      file: pkg.main,
      sourcemap: true,
    }
  }),

  // IIFE bundles for individual source files (for coverage testing)
  ...coverageBundles
];