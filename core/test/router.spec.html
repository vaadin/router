<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>vaadin-router-core tests</title>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../dist/umd/vaadin-router-core.js"></script>
</head>

<body>
  <test-fixture id="outlet">
    <template>
      <div></div>
    </template>
  </test-fixture>

  <script>
    describe('Vaadin.Router', function() {
      this.title = this.title + (window.ShadyDOM ? ' (Shady DOM)' : '');

      var outlet;
      beforeEach(() => {
        // reset the URL
        window.history.pushState(null, null, '/');

        // stamp the test fixture DOM into the page
        outlet = fixture('outlet');
      });

      describe('JS API (basic functionality)', () => {
        describe('new Router(outlet?, options?)', () => {
          it('should work without arguments', () => {
            const router = new Vaadin.Router();
            expect(router).to.be.ok;
          });

          it('should accept a router outlet DOM Node as the 1st argument', () => {
            const router = new Vaadin.Router(outlet);
            const actual = router.getOutlet();
            expect(actual).to.equal(outlet);
          });

          it('should throw if the router outlet is truthy but is not valid a DOM Node', () => {
            [
              true,
              42,
              '<slot></slot>',
              {},
              [document.body],
              () => document.body
            ].forEach(arg => {
              expect(() => new Vaadin.Router(arg), `${arg}`).to.throw(TypeError);
            });
          });

          it('should accept an options object as the 2nd argument', () => {
            const router = new Vaadin.Router(null, {baseUrl: '/users'});
            expect(router).to.have.property('baseUrl', '/users');
          });
        });

        describe('router.render(pathname)', () => {
          const add100msDelay = () => {
            return new Promise((resolve, reject) => {
              setTimeout(() => resolve(), 100);
            });
          }

          let router;
          beforeEach(() => {
            router = new Vaadin.Router(outlet);
          });

          afterEach(() => {
            router.unsubscribe();
          });

          it('should throw if the router outlet is not a valid DOM Node (on start)', () => {
            [
              undefined,
              null,
              0,
              false,
              '',
              NaN
            ].forEach(invalidOutlet => {
              router.setOutlet(invalidOutlet);
              expect(() => router.render('/'), `${invalidOutlet}`).to.throw(TypeError);
            });
          });

          it('should throw if the router outlet is a not valid DOM Node (on finish)', async () => {
            await Promise.all([
              undefined,
              null,
              0,
              false,
              '',
              NaN
            ].map(async (invalidOutlet) => {
              const router = new Vaadin.Router(outlet);
              router.setRoutes([{path: '/', component: 'x-home-view'}]);
              const fulfilled = sinon.spy();
              const rejected = sinon.spy();
              const ready = router.render('/').then(fulfilled).catch(rejected);
              router.setOutlet(invalidOutlet);
              await ready;
              expect(fulfilled).to.not.have.been.called;
              expect(rejected).to.have.been.called.once;
              expect(rejected.args[0][0]).to.be.instanceof(TypeError);
              router.unsubscribe();
            }));
          });
          
          it('should return a promise that resolves to the router outlet DOM element', async () => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            const result = router.render('/');
            expect(result).to.be.a('promise');
            const actual = await result;
            expect(actual).to.equal(outlet);
          });

          it('should return a promise that resolves when the rendered content is appended to the DOM', async () => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            const promise = router.render('/');
            expect(outlet.children).to.have.lengthOf(0);
            await promise;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should return a promise that gets rejected on no-match', (done) => {
            const result = router.render('/path/not/defined');
            result
              .then(() => fail('the promise should have been rejected'))
              .catch(() => done());
          });

          it('should create and append a route `component` into the router outlet', async () => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            await router.render('/');
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should replace any pre-existing content of the router outlet', async () => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/users', component: 'x-users-view'},
            ]);
            await router.render('/');
            await router.render('/users');
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-users-view/i);
          });

          it('should remove any pre-existing content of the router outlet on no-match', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            await router.render('/');

            await router.render('/path/not/defined').catch(() => {});
            expect(outlet.children).to.have.lengthOf(0);
          });

          it('should ignore a successful result of a resolve pass if a new resolve pass is started before the first is completed', async () => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/slow', action: add100msDelay, children: [
                {path: '/users', component: 'x-users-view'},
              ]},
              {path: '/admin', component: 'x-admin-view'},
            ]);
            await Promise.all([
              router.render('/slow/users'), // start the first resolve pass
              router.render('/admin'), // start the second resolve pass before the first is completed
            ]);
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-admin-view/i);
          });

          it('should ignore an error result of a resolve pass if a new resolve pass is started before the first is completed', async () => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/slow', action: add100msDelay, children: [
                {path: '/users', component: 'x-users-view'},
              ]},
              {path: '/admin', component: 'x-admin-view'},
            ]);
            await Promise.all([
              router.render('/slow/non-existent').catch(() => {}), // start the first resolve pass
              router.render('/admin'), // start the second resolve pass before the first is completed
            ]);
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-admin-view/i);
          });
        });

        describe('navigation events', () => {
          let router;
          beforeEach(async() => {
            router = new Vaadin.Router(outlet);
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/admin', component: 'x-admin-view'},
            ]);
            await router.render('/admin');
          });

          afterEach(() => {
            router.unsubscribe();
          });

          it('should automatically subscribe to popstate events when created', async() => {
            window.dispatchEvent(new PopStateEvent('popstate', {state: null}));
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should handle popstate events as navigation triggers', async() => {
            window.dispatchEvent(new PopStateEvent('popstate', {state: null}));
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should unsubscribe from popstate events after an `unsubscribe()` method call', async() => {
            router.unsubscribe();
            window.dispatchEvent(new PopStateEvent('popstate', {state: null}));
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-admin-view/i);
          });

          it('should subscribe to popstate events after a `subscribe()` method call', async() => {
            router.unsubscribe();
            router.subscribe();
            window.dispatchEvent(new PopStateEvent('popstate', {state: null}));
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should handle updates to the routes config as navigation triggers', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should ignore navigation events if no routes are set', async() => {
            router.setRoutes([]);
            await router.ready;

            window.dispatchEvent(new PopStateEvent('popstate', {state: null}));
            const fulfilled = sinon.spy();
            const rejected = sinon.spy();
            await router.ready.then(fulfilled).catch(rejected);
            expect(rejected).to.not.have.been.called;
          });
        });
      });
    });
  </script>
</body>
