<!--
@license
Copyright (c) 2018 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../polymer/lib/mixins/properties-mixin.html">
<link rel="import" href="vaadin-history-state-change-mixin.html">

<!-- the lib/universal-router.js file is generated by the 'lib' gulp task -->
<script src="lib/universal-router.js"></script>

<script>
  (function() {
    /**
     * `<vaadin-router>` is a Web Component that renders different content for different URLs. This
     * enables client-side routing. Each content alternative is defined with a `<vaadin-route>` component:
     *
     * ```
     * <vaadin-router>
     *   <vaadin-route path="/">
     *     <template>
     *       <h1>Home</h1>
     *     </template>
     *   </vaadin-route>
     *   <vaadin-route path="/users" component="x-user-list"></vaadin-route>
     * </vaadin-router>
     * ```
     * 
     * @customElement
     * @memberof Vaadin
     * @demo demo/
     */
    class RouterElement extends Vaadin.HistoryStateChangeMixin(Polymer.PropertiesMixin(HTMLElement)) {
      static get is() {
        return 'vaadin-router';
      }

      static get properties() {
        return {
          /** the root URL for this router */
          root: String
        };
      }

      constructor() {
        super();        
        this.attachShadow({mode: 'open'});
        this.__routes = [];
      }

      connectedCallback() {
        super.connectedCallback();
        if (!this.__router || !this.__router.baseUrl === this.root) {
          this.__router = this.__createRouter();
        }
      }

      /**
       * (override of `Polymer.PropertiesChanged._propertiesChanged`)
       * 
       * Callback called when any properties with accessors created via
       * `_createPropertyAccessor` have been set.
       *
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {!Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {!Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @return {void}
       * @protected
       */
       _propertiesChanged(currentProps, changedProps, oldProps) {
        super._propertiesChanged(currentProps, changedProps, oldProps);

        if ('root' in changedProps && this.__router && this.__router.baseUrl !== changedProps.root) {
          // TODO: modify UniversalRouter to allow updating the base URL without recreating the entire object
          this.__router = this.__createRouter();
        }
      }

      addRoute(route) {
        RouterElement.ensureRoute(route);
        this.__routes.push(route);
        this.resolve();
      }

      removeRoute(route) {
        RouterElement.ensureRoute(route);
        const index = this.__routes.indexOf(route);
        if (index > -1) {
          this.__routes.splice(index, 1);
        }
        this.resolve();
      }

      addRoutes(routes) {
        RouterElement.ensureRoutes(routes);
        this.__routes.push(...routes);
        this.resolve();
      }

      resolve() {
        if (this.__routes.length > 0 && !this.__resolveEnqueued) {
          this.__resolveEnqueued = Promise.resolve().then(() => this.__resolve());
        }
      }

      __resolve() {
        this.__resolveEnqueued = undefined;
        this.__router
          .resolve(window.location.pathname)
          .then(page => {
            if (this.__outlet) {
              this.__outlet.parentNode.removeChild(this.__outlet);
            }
            this.__outlet = document.createElement('div');
            this.__outlet.appendChild(page);
            this.shadowRoot.appendChild(this.__outlet);
          });
      }

      __createRouter() {
        return new UniversalRouter(this.__routes, {
          baseUrl: this.root,
          resolveRoute: (context, params) => {
            // TODO: export this from UniversalRouter
            if (typeof context.route.action === 'function') {
              return context.route.action(context, params)
            } else if (typeof context.route.component === 'string') {
              return RouterElement.renderComponent(context.route.component, context);
            }
            return undefined
          }
        });
      }

      /**
       * (override of `Vaadin.HistoryStateChangeMixin.onHistoryStateChanged`)
       * 
       * Callback called when the 'popstate' event is triggered on the window.
       *
       * @param {Object} state the state object associated with the active history entry
       * @param {!string} pathname the current path
       * @return {void}
       */
      onHistoryStateChanged(state, pathname) {
        this.resolve();
      }

      static ensureRoute(route) {
        if (!route || typeof route.path !== 'string') {
          const message = `a route for <vaadin-router> should be an object with a 'path' string property`;
          console.error(message, route);
          throw new Error(message);
        }
      }

      static ensureRoutes(routes) {
        if (!routes || !routes.forEach) {
          const message = `a routes array for <vaadin-router> should be a non-null object`;
          console.error(message, routes);
          throw new Error(message);
        }
        routes.forEach(route => RouterElement.ensureRoute(route));
      }

      static renderComponent(component, context) {
        const element = document.createElement(component);
        for (const param of Object.keys(context.params)) {
          element[param] = context.params[param];
        }
        return element;
      }
    }

    customElements.define(RouterElement.is, RouterElement);

    /**
     * @namespace Vaadin
     */
    window.Vaadin = window.Vaadin || {};
    Vaadin.RouterElement = RouterElement;
  })();
</script>
