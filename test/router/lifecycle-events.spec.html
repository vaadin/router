<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>Vaadin.Router Livecycle Events spec</title>
  <script src="../../bower_components/web-component-tester/browser.js"></script>
  <script src="../../bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../dist/vaadin-router.umd.js"></script>
  <script src="test-utils.js"></script>

  <link rel="import" href="../test-pushstate-throttler.html">
  <script src="../utils/register-element.js"></script>
</head>

<body>
  <test-pushstate-throttler id="throttler"></test-pushstate-throttler>
  <div id="outlet"></div>

  <script>
    class XSpy extends HTMLElement {
      constructor() {
        super();
        this.name = `x-spy#${XSpy.__instanceCount++}`;
      }
      connectedCallback() {
        this.log('connectedCallback');
      }
      disconnectedCallback() {
        this.log('disconnectedCallback');
      }
      onBeforeEnter() {
        this.log('onBeforeEnter');
      }
      onAfterEnter() {
        this.log('onAfterEnter');
      }
      onBeforeLeave() {
        this.log('onBeforeLeave');
      }
      onAfterLeave() {
        this.log('onAfterLeave');
      }

      log(message) {
        XSpy.log(() => `${this.name}.${message}`);
      }
    }
    customElements.define('x-spy', XSpy);

    XSpy.__instanceCount = 0;
    XSpy.__log = [];
    XSpy.log = (message) => {
      XSpy.__log.push(message);
    };
    XSpy.getLog = () => {
      return XSpy.__log.map(entry => `${typeof entry === 'function' ? entry() : entry}`);
    };
    XSpy.clearLog = () => {
      XSpy.__log.length = 0;
    };

    describe('Vaadin.Router lifecycle events', function() {
      const {verifyActiveRoutes} = VaadinTestNamespace;

      // eslint-disable-next-line no-invalid-this
      const suite = this;
      suite.title = suite.title + (window.ShadyDOM ? ' (Shady DOM)' : '');

      const outlet = document.getElementById('outlet');
      const throttler = document.getElementById('throttler');
      let router;
      beforeEach(async function() {
        // eslint-disable-next-line no-invalid-this
        const test = this;

        // if necessary wait before it's OK to call history.pushState again
        await throttler.throttle(test);

        // reset the window URL
        window.history.pushState(null, null, '/');

        // create a new router instance
        router = new Vaadin.Router(outlet);
      });

      afterEach(() => {
        router.unsubscribe();
      });

      describe('onBeforeEnter', () => {
        it('should be called with the router context as the only argument', async() => {
          const onBeforeEnter = sinon.spy();
          router.setRoutes([
            {path: '/', action: onBeforeEnterAction('x-home-view', onBeforeEnter)}
          ]);

          await router.render('/');

          expect(onBeforeEnter).to.have.been.called.once;
          expect(onBeforeEnter.args[0].length).to.equal(1);

          const context = onBeforeEnter.args[0][0];
          expect(context.pathname).to.equal('/');
          expect(context.route.path).to.equal('/');
          expect(context.cancel).to.be.a('function');
          expect(context.redirect).to.be.a('function');
          expect(context.component).to.be.an('undefined');
          expect(context.next).to.be.an('undefined');

          expect(outlet.children[0].tagName).to.match(/x-home-view/i);
        });

        it('should be called on the route web component instance (as `this`)', async() => {
          const onBeforeEnter = sinon.spy();
          router.setRoutes([
            {path: '/', action: onBeforeEnterAction('x-home-view', onBeforeEnter)},
          ]);

          await router.render('/');

          expect(onBeforeEnter).to.have.been.calledOn(outlet.children[0]);
          expect(outlet.children[0].tagName).to.match(/x-home-view/i);
        });

        it('should be able to return a `cancel` result to prevent navigation', async() => {
          router.setRoutes([
            {path: '/', action: onBeforeEnterAction('whatever', context => context.cancel())},
            {path: '/users', component: 'x-users-list'}
          ]);

          await router.render('/users');
          await router.render('/');

          expect(outlet.children[0].tagName).to.match(/x-users-list/i);
          verifyActiveRoutes(router, ['/users']);
        });

        it('should be able to return a `redirect` result to redirect navigation', async() => {
          router.setRoutes([
            {path: '/', action: onBeforeEnterAction('whatever', context => context.redirect('/users'))},
            {path: '/users', component: 'x-users-list'}
          ]);

          await router.render('/');

          expect(outlet.children[0].tagName).to.match(/x-users-list/i);
          verifyActiveRoutes(router, ['/users']);
        });

        it('should ignore any other return value than `cancel` or `redirect`', async() => {
          const values = [
            true,
            false,
            0,
            42,
            [],
            {not_a_redirect: true},
            null,
            undefined,
            () => true,
            'random-tag-name',
            document.createElement('div'),
          ];

          for (let i = 0; i < values.length; i += 1) {
            const onBeforeEnter = sinon.stub().returns(values[i]);
            router.setRoutes([
              {path: '/', action: onBeforeEnterAction('x-home-view', onBeforeEnter)},
              {path: '/users', component: 'x-users-list'},
            ]);

            await router.render('/');
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
            verifyActiveRoutes(router, ['/']);
          }
        });

        it('should support returning a promise (and continue the resolve pass after the promise resolves)', async() => {
          router.setRoutes([
            {
              path: '/a',
              action: onBeforeEnterAction('x-spy', function() {
                // eslint-disable-next-line no-invalid-this
                const self = this;
                self.log('onBeforeEnter');
                return new Promise(resolve => {
                  setTimeout(() => {
                    self.log('onBeforeEnter.promise');
                    resolve();
                  }, 100);
                });
              })
            },
            {path: '/b', component: 'x-spy'},
          ]);

          await router.render('/').catch(() => {});
          XSpy.clearLog();

          await router.render('/a').then((outlet) => {
            outlet.children[0].name = 'a';
          });

          expect(XSpy.getLog()).to.deep.equal([
            'a.onBeforeEnter',
            'a.onBeforeEnter.promise',
            'a.connectedCallback',
            'a.onAfterEnter',
          ]);
        });

        it('should not re-render the same component if `onBeforeLeave` prevented navigation', async() => {
          let counter = 0;
          customElements.define('x-persistent-view', class extends HTMLElement {
            connectedCallback() {
              counter++;
            }
            onBeforeLeave(context) {
              return context.cancel();
            }
          });
          router.setRoutes([
            {path: '/', component: 'x-home-view'},
            {path: '/users', component: 'x-persistent-view'},
          ]);
          await router.render('/users');
          await router.render('/');
          expect(outlet.children[0].tagName).to.match(/x-persistent-view/i);
          expect(counter).to.equal(1);
        });
      });

      describe('onBeforeLeave', () => {
        it('should be called with the router context as the only argument', async() => {
          const onBeforeLeave = sinon.spy();
          router.setRoutes([
            {path: '/', action: onBeforeLeaveAction('x-home-view', onBeforeLeave)},
            {path: '/users', component: 'x-users-list'},
          ]);

          await router.render('/');
          expect(onBeforeLeave).to.not.have.been.called;

          await router.render('/users');

          expect(onBeforeLeave).to.have.been.called.once;
          expect(onBeforeLeave.args[0].length).to.equal(1);

          const context = onBeforeLeave.args[0][0];
          expect(context.pathname).to.equal('/users');
          expect(context.route.path).to.equal('/users');
          expect(context.cancel).to.be.a('function');
          expect(context.redirect).to.be.an('undefined');
          expect(context.component).to.be.an('undefined');
          expect(context.next).to.be.an('undefined');

          expect(outlet.children[0].tagName).to.match(/x-users-list/i);
        });

        it('should be called on the route web component instance (as `this`)', async() => {
          const onBeforeLeave = sinon.spy();
          router.setRoutes([
            {path: '/', action: onBeforeLeaveAction('x-home-view', onBeforeLeave)},
            {path: '/users', component: 'x-users-list'},
          ]);

          await router.render('/');
          const homeViewElement = outlet.children[0];

          await router.render('/users');

          expect(onBeforeLeave).to.have.been.calledOn(homeViewElement);
          expect(outlet.children[0].tagName).to.match(/x-users-list/i);
        });

        it('should be able to return a `cancel` result to prevent navigation', async() => {
          router.setRoutes([
            {path: '/', action: onBeforeLeaveAction('x-home-view', context => context.cancel())},
            {path: '/users', component: 'x-users-list'},
          ]);

          await router.render('/');
          await router.render('/users');

          expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          verifyActiveRoutes(router, ['/']);
        });

        it('should ignore any other return value than `cancel`', async() => {
          const values = [
            true,
            false,
            0,
            42,
            [],
            {not_a_redirect: true},
            {redirect: {pathname: '/'}},
            null,
            undefined,
            () => true,
            'random-tag-name',
            document.createElement('div'),
          ];

          for (let i = 0; i < values.length; i += 1) {
            const onBeforeLeave = sinon.stub().returns(values[i]);
            router.setRoutes([
              {path: '/', action: onBeforeLeaveAction('x-home-view', onBeforeLeave)},
              {path: '/users', component: 'x-users-list'},
            ]);

            await router.render('/');
            await router.render('/users');
            expect(outlet.children[0].tagName).to.match(/x-users-list/i);
            verifyActiveRoutes(router, ['/users']);
          }
        });

        it('should support returning a promise (and continue the resolve pass after the promise resolves)', async() => {
          router.setRoutes([
            {
              path: '/a',
              action: onBeforeLeaveAction('x-spy', function() {
                // eslint-disable-next-line no-invalid-this
                const self = this;
                self.log('onBeforeLeave');
                return new Promise(resolve => {
                  setTimeout(() => {
                    self.log('onBeforeLeave.promise');
                    resolve();
                  }, 100);
                });
              })
            },
            {path: '/b', component: 'x-spy'},
          ]);

          await router.render('/').catch(() => {});
          await router.render('/a').then((outlet) => {
            outlet.children[0].name = 'a';
          });
          XSpy.clearLog();
          await router.render('/b').then((outlet) => {
            outlet.children[0].name = 'b';
          });

          expect(XSpy.getLog()).to.deep.equal([
            'a.onBeforeLeave',
            'a.onBeforeLeave.promise',
            'b.onBeforeEnter',
            'a.disconnectedCallback',
            'b.connectedCallback',
            'b.onAfterEnter',
          ]);
        });

        it('should wait until the animation on the component is executed', async() => {
          const element = 'x-leaving-animation-view';

          registerElement(
            element,
            `
              <style>
                @keyframes fadeOut {
                  from {
                    opacity: 1;
                  }
                  to {
                    opacity: 0;
                  }
                }
                :host([animating]) {
                  animation: 50ms fadeOut;
                }
              </style>
            `,
            {
              onBeforeLeave: function() {
                return Vaadin.Router.Transitions.animate(this);
              }
            }
          );

          router.setRoutes([
            {path: '/', component: 'x-home-view'},
            {path: '/animate', component: element}
          ]);

          await router.render('/animate');

          const spy = sinon.spy();
          outlet.children[0].addEventListener('animationend', spy);

          await router.render('/');
          expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          expect(spy).to.be.calledOnce;
        });

        it('should not re-render the same component if `onBeforeEnter` prevented navigation', async() => {
          let counter = 0;
          customElements.define('x-root-view', class extends HTMLElement {
            connectedCallback() {
              counter++;
            }
          });
          customElements.define('x-disallowed-view', class extends HTMLElement {
            onBeforeEnter(context) {
              return context.cancel();
            }
          });
          router.setRoutes([
            {path: '/', component: 'x-root-view'},
            {path: '/users', component: 'x-disallowed-view'},
          ]);
          await router.render('/');
          await router.render('/users');
          expect(outlet.children[0].tagName).to.match(/x-root-view/i);
          expect(counter).to.equal(1);
        });
      });

      describe('onAfterEnter', () => {
        it('should be called with the router context as the only argument', async() => {
          const onAfterEnter = sinon.spy();
          router.setRoutes([
            {path: '/', action: onAfterEnterAction('x-home-view', onAfterEnter)}
          ]);

          await router.render('/');

          expect(onAfterEnter).to.have.been.called.once;
          expect(onAfterEnter.args[0].length).to.equal(1);

          const context = onAfterEnter.args[0][0];
          expect(context.pathname).to.equal('/');
          expect(context.route.path).to.equal('/');
          expect(context.cancel).to.be.an('undefined');
          expect(context.redirect).to.be.an('undefined');
          expect(context.component).to.be.an('undefined');
          expect(context.next).to.be.an('undefined');

          expect(outlet.children[0].tagName).to.match(/x-home-view/i);
        });

        it('should be called on the route web component instance (as `this`)', async() => {
          const onAfterEnter = sinon.spy();
          router.setRoutes([
            {path: '/', action: onAfterEnterAction('x-home-view', onAfterEnter)},
          ]);

          await router.render('/');

          expect(onAfterEnter).to.have.been.calledOn(outlet.children[0]);
          expect(outlet.children[0].tagName).to.match(/x-home-view/i);
        });

        it('should ignore all return values', async() => {
          const values = [
            true,
            false,
            0,
            42,
            [],
            {not_a_redirect: true},
            {redirect: {pathname: '/'}},
            {cancel: true},
            null,
            undefined,
            () => true,
            'random-tag-name',
            document.createElement('div'),
          ];

          for (let i = 0; i < values.length; i += 1) {
            const onAfterEnter = sinon.stub().returns(values[i]);
            router.setRoutes([
              {path: '/', action: onAfterEnterAction('x-home-view', onAfterEnter)},
              {path: '/users', component: 'x-users-list'},
            ]);

            await router.render('/');
            await router.render('/users');
            expect(outlet.children[0].tagName).to.match(/x-users-list/i);
            verifyActiveRoutes(router, ['/users']);
          }
        });

        it('should support returning a promise (and continue the resolve pass after the promise resolves)', async() => {
          router.setRoutes([
            {path: '/a', component: 'x-spy'},
            {path: '/b', action: onAfterEnterAction('x-spy', function() {
              // eslint-disable-next-line no-invalid-this
              const self = this;
              self.log('onAfterEnter');
              return new Promise(resolve => {
                setTimeout(() => {
                  self.log('onAfterEnter.promise');
                  resolve();
                }, 100);
              });
            })},
          ]);

          await router.render('/').catch(() => {});
          await router.render('/a').then((outlet) => {
            outlet.children[0].name = 'a';
          });
          XSpy.clearLog();
          await router.render('/b').then((outlet) => {
            outlet.children[0].name = 'b';
          });

          expect(XSpy.getLog()).to.deep.equal([
            'a.onBeforeLeave',
            'b.onBeforeEnter',
            'a.disconnectedCallback',
            'b.connectedCallback',
            'b.onAfterEnter',
            'b.onAfterEnter.promise',
          ]);
        });
      });

      describe('the order of lifecycle events (without early returns)', () => {
        it('(initial) -> /a', async() => {
          router.setRoutes([
            {path: '/a', action: () => XSpy.log('a.action'), component: 'x-spy'},
          ]);

          await router.render('/').catch(() => {});
          XSpy.clearLog();
          await router.render('/a').then(outlet => {
            outlet.children[0].name = 'a';
          });

          expect(XSpy.getLog()).to.deep.equal([
            'a.action',
            'a.onBeforeEnter',
            'a.connectedCallback',
            'a.onAfterEnter',
          ]);
        });

        it('/a -> /b', async() => {
          router.setRoutes([
            {path: '/a', action: () => XSpy.log('a.action'), component: 'x-spy'},
            {path: '/b', action: () => XSpy.log('b.action'), component: 'x-spy'},
          ]);

          await router.render('/a').then(outlet => {
            outlet.children[0].name = 'a';
          });
          XSpy.clearLog();
          await router.render('/b').then(outlet => {
            outlet.children[0].name = 'b';
          });

          expect(XSpy.getLog()).to.deep.equal([
            'b.action',
            'a.onBeforeLeave',
            'b.onBeforeEnter',
            'a.disconnectedCallback',
            'b.connectedCallback',
            'b.onAfterEnter',
          ]);
        });

        it('(initial) -> /a/b', async() => {
          router.setRoutes([
            {
              path: '/a',
              action: () => XSpy.log('a.action'),
              children: [
                {path: '/b', action: () => XSpy.log('b.action'), component: 'x-spy'},
              ]
            },
          ]);

          await router.render('/').catch(() => {});
          XSpy.clearLog();
          await router.render('/a/b').then(outlet => {
            outlet.children[0].name = 'b';
          });

          expect(XSpy.getLog()).to.deep.equal([
            'a.action',
            'b.action',
            'b.onBeforeEnter',
            'b.connectedCallback',
            'b.onAfterEnter',
          ]);
        });

        it('/a/b -> /a/c', async() => {
          router.setRoutes([
            {
              path: '/a',
              action: () => XSpy.log('a.action'),
              children: [
                {path: '/b', action: () => XSpy.log('b.action'), component: 'x-spy'},
                {path: '/c', action: () => XSpy.log('c.action'), component: 'x-spy'},
              ]
            },
          ]);

          await router.render('/a/b').then(outlet => {
            outlet.children[0].name = 'b';
          });
          XSpy.clearLog();
          await router.render('/a/c').then(outlet => {
            outlet.children[0].name = 'c';
          });

          expect(XSpy.getLog()).to.deep.equal([
            'a.action',
            'c.action',
            'b.onBeforeLeave',
            'c.onBeforeEnter',
            'b.disconnectedCallback',
            'c.connectedCallback',
            'c.onAfterEnter',
          ]);
        });

        it('(initial) -> /a/non-existent-path', async() => {
          await router.render('/').catch(() => {});
          XSpy.clearLog();

          // call 'setRoutes' without triggering a navigation event
          Vaadin.Resolver.prototype.setRoutes.call(router, [
            {
              path: '/a',
              action: () => XSpy.log('a.action'),
              children: [
                {path: '/b', action: () => XSpy.log('b.action'), component: 'x-spy'},
              ]
            },
            {path: '(.*)', action: () => XSpy.log('*.action'), component: 'x-spy'},
          ]);
          await router.render('/a/non-existent-path').then(outlet => {
            outlet.children[0].name = '*';
          });

          expect(XSpy.getLog()).to.deep.equal([
            'a.action',
            '*.action',
            '*.onBeforeEnter',
            '*.connectedCallback',
            '*.onAfterEnter',
          ]);
        });

        it('/a/b -> /a/non-existent-path', async() => {
          router.setRoutes([
            {
              path: '/a',
              action: () => XSpy.log('a.action'),
              children: [
                {path: '/b', action: () => XSpy.log('b.action'), component: 'x-spy'},
              ]
            },
            {path: '(.*)', action: () => XSpy.log('*.action'), component: 'x-spy'},
          ]);

          await router.render('/a/b').then(outlet => {
            outlet.children[0].name = 'b';
          });
          XSpy.clearLog();
          await router.render('/a/non-existent-path').then(outlet => {
            outlet.children[0].name = '*';
          });

          expect(XSpy.getLog()).to.deep.equal([
            'a.action',
            '*.action',
            'b.onBeforeLeave',
            '*.onBeforeEnter',
            'b.disconnectedCallback',
            '*.connectedCallback',
            '*.onAfterEnter',
          ]);
        });

        it('/a/c -> /a/d (/a gets visited, but does not get matched)', async() => {
          router.setRoutes([
            {
              path: '/a',
              action: () => XSpy.log('a.action'),
              children: [
                {path: '/b', action: () => XSpy.log('a.action'), component: 'x-spy'},
              ]
            },
            {path: '/a/c', action: () => XSpy.log('ac.action'), component: 'x-spy'},
            {path: '/a/d', action: () => XSpy.log('ad.action'), component: 'x-spy'},
          ]);

          await router.render('/a/c').then(outlet => {
            outlet.children[0].name = 'ac';
          });
          XSpy.clearLog();
          await router.render('/a/d').then(outlet => {
            outlet.children[0].name = 'ad';
          });

          expect(XSpy.getLog()).to.deep.equal([
            'a.action',
            'ad.action',
            'ac.onBeforeLeave',
            'ad.onBeforeEnter',
            'ac.disconnectedCallback',
            'ad.connectedCallback',
            'ad.onAfterEnter',
          ]);
        });

        it('/users/Jane -> /users/John (when parameters are changed, no extra callbacks are called)', async() => {
          router.setRoutes([
            {path: '/users/:user', action: () => XSpy.log('route.action'), component: 'x-spy'},
          ]);

          await router.render('/users/Jane');
          XSpy.clearLog();
          await router.render('/users/John').then(outlet => {
            outlet.children[0].name = 'john';
          });

          expect(XSpy.getLog()).to.deep.equal(['route.action']);
        });
      });
    });

    function onBeforeLeaveAction(componentName, callback) {
      return context => {
        const component = context.component(componentName);
        component.onBeforeLeave = callback;
        return component;
      };
    }

    function onBeforeEnterAction(componentName, callback) {
      return context => {
        const component = context.component(componentName);
        component.onBeforeEnter = callback;
        return component;
      };
    }

    function onAfterEnterAction(componentName, callback) {
      return context => {
        const component = context.component(componentName);
        component.onAfterEnter = callback;
        return component;
      };
    }
  </script>
</body>
