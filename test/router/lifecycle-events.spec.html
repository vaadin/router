<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>Vaadin.Router Livecycle Events spec</title>
  <script src="../../bower_components/web-component-tester/browser.js"></script>
  <script src="../../bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../dist/vaadin-router.umd.js"></script>

  <link rel="import" href="../test-pushstate-throttler.html">
</head>

<body>
  <test-pushstate-throttler id="throttler"></test-pushstate-throttler>
  <div id="outlet"></div>

  <script>
    class XSpy extends HTMLElement {
      constructor() {
        super();
        this.name = `x-spy#${XSpy.__instanceCount++}`;
      }
      connectedCallback() {
        this.log('connectedCallback');
      }
      disconnectedCallback() {
        this.log('disconnectedCallback');
      }
      onBeforeEnter() {
        this.log('onBeforeEnter');
      }
      onAfterEnter() {
        this.log('onAfterEnter');
      }
      onBeforeLeave() {
        this.log('onBeforeLeave');
      }
      onAfterLeave() {
        this.log('onAfterLeave');
      }

      log(message) {
        XSpy.log(() => `${this.name}.${message}`);
      }
    }
    customElements.define('x-spy', XSpy);

    XSpy.__instanceCount = 0;
    XSpy.__log = [];
    XSpy.log = (message) => {
      XSpy.__log.push(message);
    };
    XSpy.getLog = () => {
      return XSpy.__log.map(entry => `${typeof entry === 'function' ? entry() : entry}`);
    };
    XSpy.clearLog = () => {
      XSpy.__log.length = [];
    };

    describe('Vaadin.Router lifecycle events', function() {
      // eslint-disable-next-line no-invalid-this
      const suite = this;
      suite.title = suite.title + (window.ShadyDOM ? ' (Shady DOM)' : '');

      const outlet = document.getElementById('outlet');
      const throttler = document.getElementById('throttler');
      let router;
      beforeEach(async function() {
        // eslint-disable-next-line no-invalid-this
        const test = this;

        // if necessary wait before it's OK to call history.pushState again
        await throttler.throttle(test);

        // reset the window URL
        window.history.pushState(null, null, '/');

        // create a new router instance
        router = new Vaadin.Router(outlet);
      });

      afterEach(() => {
        router.unsubscribe();
      });

      describe('lifecycle events order: no early returns', () => {
        it('(initial) -> /a', async() => {
          router.setRoutes([
            {path: '/a', action: () => XSpy.log('a.action'), component: 'x-spy'},
          ]);

          await router.render('/').catch(() => {});
          XSpy.clearLog();
          await router.render('/a').then(outlet => {
            outlet.children[0].name = 'a';
          });

          expect(XSpy.getLog()).to.deep.equal([
            'a.action',
            'a.onBeforeEnter',
            'a.connectedCallback',
            'a.onAfterEnter',
          ]);
        });

        it('/a -> /b', async() => {
          router.setRoutes([
            {path: '/a', action: () => XSpy.log('a.action'), component: 'x-spy'},
            {path: '/b', action: () => XSpy.log('b.action'), component: 'x-spy'},
          ]);

          await router.render('/a').then(outlet => {
            outlet.children[0].name = 'a';
          });
          XSpy.clearLog();
          await router.render('/b').then(outlet => {
            outlet.children[0].name = 'b';
          });

          expect(XSpy.getLog()).to.deep.equal([
            'b.action',
            'a.onBeforeLeave',
            'b.onBeforeEnter',
            'a.disconnectedCallback',
            'b.connectedCallback',
            'b.onAfterEnter',
          ]);
        });

        it('(initial) -> /a/b', async() => {
          router.setRoutes([
            {
              path: '/a',
              action: () => XSpy.log('a.action'),
              children: [
                {path: '/b', action: () => XSpy.log('b.action'), component: 'x-spy'},
              ]
            },
          ]);

          await router.render('/').catch(() => {});
          XSpy.clearLog();
          await router.render('/a/b').then(outlet => {
            outlet.children[0].name = 'b';
          });

          expect(XSpy.getLog()).to.deep.equal([
            'a.action',
            'b.action',
            'b.onBeforeEnter',
            'b.connectedCallback',
            'b.onAfterEnter',
          ]);
        });

        it('/a/b -> /a/c', async() => {
          router.setRoutes([
            {
              path: '/a',
              action: () => XSpy.log('a.action'),
              children: [
                {path: '/b', action: () => XSpy.log('b.action'), component: 'x-spy'},
                {path: '/c', action: () => XSpy.log('c.action'), component: 'x-spy'},
              ]
            },
          ]);

          await router.render('/a/b').then(outlet => {
            outlet.children[0].name = 'b';
          });
          XSpy.clearLog();
          await router.render('/a/c').then(outlet => {
            outlet.children[0].name = 'c';
          });

          expect(XSpy.getLog()).to.deep.equal([
            'a.action',
            'c.action',
            'b.onBeforeLeave',
            'c.onBeforeEnter',
            'b.disconnectedCallback',
            'c.connectedCallback',
            'c.onAfterEnter',
          ]);
        });

        it('(initial) -> /a/non-existent-path', async() => {
          router.setRoutes([
            {
              path: '/a',
              action: () => XSpy.log('a.action'),
              children: [
                {path: '/b', action: () => XSpy.log('b.action'), component: 'x-spy'},
              ]
            },
            {path: '(.*)', action: () => XSpy.log('*.action'), component: 'x-spy'},
          ]);

          await router.render('/').catch(() => {});
          XSpy.clearLog();
          await router.render('/a/non-existent-path').then(outlet => {
            outlet.children[0].name = '*';
          });

          expect(XSpy.getLog()).to.deep.equal(['a.action', '*.action']);
        });

        it('/a/b -> /a/non-existent-path', async() => {
          router.setRoutes([
            {
              path: '/a',
              action: () => XSpy.log('a.action'),
              children: [
                {path: '/b', action: () => XSpy.log('b.action'), component: 'x-spy'},
              ]
            },
            {path: '(.*)', action: () => XSpy.log('*.action'), component: 'x-spy'},
          ]);

          await router.render('/a/b').then(outlet => {
            outlet.children[0].name = 'b';
          });
          XSpy.clearLog();
          await router.render('/a/non-existent-path').then(outlet => {
            outlet.children[0].name = '*';
          });

          expect(XSpy.getLog()).to.deep.equal([
            'a.action',
            '*.action',
            'b.onBeforeLeave',
            '*.onBeforeEnter',
            'b.disconnectedCallback',
            '*.connectedCallback',
            '*.onAfterEnter',
          ]);
        });

        it('/a/c -> /a/d (/a gets visited, but does not get matched)', async() => {
          router.setRoutes([
            {
              path: '/a',
              action: () => XSpy.log('a.action'),
              children: [
                {path: '/b', action: () => XSpy.log('a.action'), component: 'x-spy'},
              ]
            },
            {path: '/a/c', action: () => XSpy.log('ac.action'), component: 'x-spy'},
            {path: '/a/d', action: () => XSpy.log('ad.action'), component: 'x-spy'},
          ]);

          await router.render('/a/c').then(outlet => {
            outlet.children[0].name = 'ac';
          });
          XSpy.clearLog();
          await router.render('/a/d').then(outlet => {
            outlet.children[0].name = 'ad';
          });

          expect(XSpy.getLog()).to.deep.equal([
            'a.action',
            'ad.action',
            'ac.onBeforeLeave',
            'ad.onBeforeEnter',
            'ac.disconnectedCallback',
            'ad.connectedCallback',
            'ad.onAfterEnter',
          ]);
        });

        it('/users/Jane -> /users/John (when parameters are changed, no extra callbacks are called)', async() => {
          router.setRoutes([
            {path: '/users/:user', action: () => XSpy.log('route.action'), component: 'x-spy'},
          ]);

          await router.render('/users/Jane');
          XSpy.clearLog();
          await router.render('/users/John').then(outlet => {
            outlet.children[0].name = 'john';
          });

          expect(XSpy.getLog()).to.deep.equal(['route.action']);
        });
      });
    });
  </script>
</body>
