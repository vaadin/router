<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>Vaadin Router Livecycle Events spec</title>
  <script src="../../bower_components/web-component-tester/browser.js"></script>
  <script src="../../bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../dist/vaadin-router.umd.js"></script>
  <script src="test-utils.js"></script>

  <link rel="import" href="../test-pushstate-throttler.html">
</head>

<body>
  <test-pushstate-throttler id="throttler"></test-pushstate-throttler>
  <test-fixture id="outlet">
    <template>
      <div></div>
    </template>
  </test-fixture>

  <script>
    class XSpy extends HTMLElement {
      connectedCallback() {
        callbacksLog.push(`${this.name}.connectedCallback`);
      }
      disconnectedCallback() {
        callbacksLog.push(`${this.name}.disconnectedCallback`);
      }
      onBeforeEnter() {
        callbacksLog.push(`${this.name}.onBeforeEnter`);
      }
      onAfterEnter() {
        callbacksLog.push(`${this.name}.onAfterEnter`);
      }
      onBeforeLeave() {
        callbacksLog.push(`${this.name}.onBeforeLeave`);
      }
      onAfterLeave() {
        callbacksLog.push(`${this.name}.onAfterLeave`);
      }
      set location(location) {
        // Note: initially, command.component(elementName) invokes location
        // setter, but `this.name` is `undefined` at the moment, and so it logs.
        callbacksLog.push(`${this.name}.location setter`);
      }
    }
    customElements.define('x-spy', XSpy);

    let callbacksLog = [];

    const elementWithAllLifecycleCallbacks = elementName => (context, commands) => {
      callbacksLog.push(`${elementName}.action`);
      const component = commands.component('x-spy');
      component.name = elementName;
      return component;
    };

    const elementWithUserParameter = () => (context, commands) => {
      const elementName = `x-user-${context.params.user}`;
      callbacksLog.push(`${elementName}.action`);
      const component = commands.component('x-spy');
      if (!component.name) {
        component.name = elementName;
      }
      return component;
    };

    describe('Vaadin Router lifecycle events', function() {
      const {
        verifyActiveRoutes,
        onAfterEnterAction,
        onAfterLeaveAction,
        onBeforeEnterAction,
        onBeforeLeaveAction
      } = VaadinTestNamespace;

      const verifyCallbacks = expectedCallbacks => {
        expect(callbacksLog).to.be.an('array');
        expect(expectedCallbacks).to.be.an('array');

        try {
          expect(callbacksLog).to.deep.equal(expectedCallbacks);
        } catch (e) {
          if (console.table) {
            const comparisonTable = [['expected', 'actual']];
            for (let i = 0; i < Math.max(expectedCallbacks.length, callbacksLog.length); i++) {
              comparisonTable.push([expectedCallbacks[i], callbacksLog[i]]);
            }
            console.table(comparisonTable);
          }
          throw e;
        }
      };

      // eslint-disable-next-line no-invalid-this
      const suite = this;
      suite.title = suite.title + (window.ShadyDOM ? ' (Shady DOM)' : '');

      let outlet;
      const throttler = document.getElementById('throttler');
      let router;
      beforeEach(async function() {
        // eslint-disable-next-line no-invalid-this
        const test = this;

        // if necessary wait before it's OK to call history.pushState again
        await throttler.throttle(test);

        // reset the window URL
        window.history.pushState(null, null, '/');

        // stamp the test fixture DOM into the page
        outlet = fixture('outlet');

        // create a new router instance
        router = new Vaadin.Router(outlet);
      });

      afterEach(() => {
        router.unsubscribe();
      });

      describe('onBeforeEnter', () => {
        it('should be called with 3 arguments: [location, commands, router]', async() => {
          const onBeforeEnter = sinon.spy();
          router.setRoutes([
            {path: '/', action: onBeforeEnterAction('x-home-view', onBeforeEnter)}
          ]);

          await router.render('/');

          expect(onBeforeEnter).to.have.been.called.once;
          expect(onBeforeEnter.args[0].length).to.equal(3);

          const location = onBeforeEnter.args[0][0];
          expect(location.pathname).to.equal('/');
          expect(location.route.path).to.equal('/');

          const commands = onBeforeEnter.args[0][1];
          expect(commands).to.be.an('object').that.is.not.null;

          const routerArg = onBeforeEnter.args[0][2];
          expect(routerArg).to.equal(router);

          expect(outlet.children[0].tagName).to.match(/x-home-view/i);
        });

        it('should be called on the route web component instance (as `this`)', async() => {
          const onBeforeEnter = sinon.spy();
          router.setRoutes([
            {path: '/', action: onBeforeEnterAction('x-home-view', onBeforeEnter)},
          ]);

          await router.render('/');

          expect(onBeforeEnter).to.have.been.calledOn(outlet.children[0]);
          expect(outlet.children[0].tagName).to.match(/x-home-view/i);
        });

        it('should be able to return a `prevent` command to prevent navigation', async() => {
          router.setRoutes([
            {path: '/', action: onBeforeEnterAction('whatever', (location, commands) => commands.prevent())},
            {path: '/users', component: 'x-users-list'}
          ]);

          await router.render('/users');
          await router.render('/');

          expect(outlet.children[0].tagName).to.match(/x-users-list/i);
          verifyActiveRoutes(router, ['/users']);
        });

        it('should be able to return a `redirect` command to redirect navigation', async() => {
          router.setRoutes([
            {path: '/', action: onBeforeEnterAction('whatever', (location, commands) => commands.redirect('/users'))},
            {path: '/users', component: 'x-users-list'}
          ]);

          await router.render('/');

          expect(outlet.children[0].tagName).to.match(/x-users-list/i);
          verifyActiveRoutes(router, ['/users']);
        });

        it('should be able to have multiple redirects', async() => {
          router.setRoutes([
            {path: '/', action: onBeforeEnterAction('x-redirect-component', (location, commands) => commands.redirect('/u'))},
            {path: '/u', action: onBeforeEnterAction('x-redirect-component', (location, commands) => commands.redirect('/users'))},
            {path: '/users', component: 'x-users-list'}
          ]);

          await router.render('/');

          expect(outlet.children[0].tagName).to.match(/x-users-list/i);
          verifyActiveRoutes(router, ['/users']);
        });

        it('should fail on recursive redirects', async() => {
          router.setRoutes([
            {path: '/', action: onBeforeEnterAction('x-redirect-component', (location, commands) => commands.redirect('/u'))},
            {path: '/u', action: onBeforeEnterAction('x-redirect-component', (location, commands) => commands.redirect('/users'))},
            {path: '/users', action: onBeforeEnterAction('x-redirect-component', (location, commands) => commands.redirect('/'))}
          ]);

          const onError = sinon.spy();
          await router.render('/').catch(onError);

          expect(outlet.children).to.have.lengthOf(0);
          expect(onError).to.have.been.called.once;
        });

        it('should ignore any other return value than `prevent` or `redirect`', async() => {
          const values = [
            true,
            false,
            0,
            42,
            [],
            {not_a_redirect: true},
            null,
            undefined,
            () => true,
            'random-tag-name',
            document.createElement('div'),
          ];

          for (let i = 0; i < values.length; i += 1) {
            const onBeforeEnter = sinon.stub().returns(values[i]);
            router.setRoutes([
              {path: '/', action: onBeforeEnterAction('x-home-view', onBeforeEnter)},
              {path: '/users', component: 'x-users-list'},
            ]);

            await router.render('/');
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
            verifyActiveRoutes(router, ['/']);
          }
        });

        it('should support returning a promise (and continue the resolve pass after the promise resolves)', async() => {
          router.setRoutes([
            {
              path: '/a',
              action: onBeforeEnterAction(
                'x-spy',
                function() {
                  callbacksLog.push('a.onBeforeEnter');
                  return new Promise(resolve => {
                    setTimeout(() => {
                      callbacksLog.push('a.onBeforeEnter.promise');
                      resolve();
                    }, 100);
                  });
                },
                'a')
            },
            {path: '/b', component: 'x-spy'},
          ]);

          await router.render('/').catch(() => {});
          callbacksLog = [];

          await router.render('/a');

          verifyCallbacks([
            'undefined.location setter',
            'a.onBeforeEnter',
            'a.onBeforeEnter.promise',
            'a.connectedCallback',
            'a.onAfterEnter',
          ]);
        });

        it('should not re-render the same component if `onBeforeLeave` prevented navigation', async() => {
          let counter = 0;
          customElements.define('x-persistent-view', class extends HTMLElement {
            connectedCallback() {
              counter++;
            }
            onBeforeLeave(location, commands) {
              return commands.prevent();
            }
          });
          router.setRoutes([
            {path: '/', component: 'x-home-view'},
            {path: '/users', component: 'x-persistent-view'},
          ]);
          await router.render('/users');
          await router.render('/');
          expect(outlet.children[0].tagName).to.match(/x-persistent-view/i);
          expect(counter).to.equal(1);
        });
      });

      describe('onBeforeLeave', () => {
        it('should be called with 3 arguments: [location, commands, router]', async() => {
          const onBeforeLeave = sinon.spy();
          router.setRoutes([
            {path: '/', action: onBeforeLeaveAction('x-home-view', onBeforeLeave)},
            {path: '/users', component: 'x-users-list'},
          ]);

          await router.render('/');
          expect(onBeforeLeave).to.not.have.been.called;

          await router.render('/users');

          expect(onBeforeLeave).to.have.been.called.once;
          expect(onBeforeLeave.args[0].length).to.equal(3);

          const location = onBeforeLeave.args[0][0];
          expect(location.pathname).to.equal('/users');
          expect(location.route.path).to.equal('/users');

          const commands = onBeforeLeave.args[0][1];
          expect(commands).to.be.an('object').that.is.not.null;

          const routerArg = onBeforeLeave.args[0][2];
          expect(routerArg).to.equal(router);

          expect(outlet.children[0].tagName).to.match(/x-users-list/i);
        });

        it('should be called on the route web component instance (as `this`)', async() => {
          const onBeforeLeave = sinon.spy();
          router.setRoutes([
            {path: '/', action: onBeforeLeaveAction('x-home-view', onBeforeLeave)},
            {path: '/users', component: 'x-users-list'},
          ]);

          await router.render('/');
          const homeViewElement = outlet.children[0];

          await router.render('/users');

          expect(onBeforeLeave).to.have.been.calledOn(homeViewElement);
          expect(outlet.children[0].tagName).to.match(/x-users-list/i);
        });

        it('should be able to return a `prevent` command to prevent navigation', async() => {
          router.setRoutes([
            {path: '/', action: onBeforeLeaveAction('x-home-view', (location, commands) => commands.prevent())},
            {path: '/users', component: 'x-users-list'},
          ]);

          await router.render('/');
          await router.render('/users');

          expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          verifyActiveRoutes(router, ['/']);
        });

        it('should ignore any other return value than `prevent`', async() => {
          const values = [
            true,
            false,
            0,
            42,
            [],
            {not_a_redirect: true},
            {redirect: {pathname: '/'}},
            null,
            undefined,
            () => true,
            'random-tag-name',
            document.createElement('div'),
          ];

          for (let i = 0; i < values.length; i += 1) {
            const onBeforeLeave = sinon.stub().returns(values[i]);
            router.setRoutes([
              {path: '/', action: onBeforeLeaveAction('x-home-view', onBeforeLeave)},
              {path: '/users', component: 'x-users-list'},
            ]);

            await router.render('/');
            await router.render('/users');
            expect(outlet.children[0].tagName).to.match(/x-users-list/i);
            verifyActiveRoutes(router, ['/users']);
          }
        });

        it('should support returning a promise (and continue the resolve pass after the promise resolves)', async() => {
          router.setRoutes([
            {
              path: '/a',
              action: onBeforeLeaveAction(
                'x-spy',
                function() {
                  callbacksLog.push('a.onBeforeLeave');
                  return new Promise(resolve => {
                    setTimeout(() => {
                      callbacksLog.push('a.onBeforeLeave.promise');
                      resolve();
                    }, 100);
                  });
                },
                'a'),
            },
            {path: '/b', action: elementWithAllLifecycleCallbacks('b')},
          ]);

          await router.render('/').catch(() => {});
          await router.render('/a');
          callbacksLog = [];
          await router.render('/b');

          verifyCallbacks([
            'b.action',
            'undefined.location setter',
            'a.onBeforeLeave',
            'a.onBeforeLeave.promise',
            'b.onBeforeEnter',
            'b.connectedCallback',
            'b.onAfterEnter',
            'a.onAfterLeave',
            'a.disconnectedCallback',
          ]);
        });

        it('should not re-render the same component if `onBeforeEnter` prevented navigation', async() => {
          let counter = 0;
          customElements.define('x-root-view', class extends HTMLElement {
            connectedCallback() {
              counter++;
            }
          });
          customElements.define('x-disallowed-view', class extends HTMLElement {
            onBeforeEnter(location, commands) {
              return commands.prevent();
            }
          });
          router.setRoutes([
            {path: '/', component: 'x-root-view'},
            {path: '/users', component: 'x-disallowed-view'},
          ]);
          await router.render('/');
          await router.render('/users');
          expect(outlet.children[0].tagName).to.match(/x-root-view/i);
          expect(counter).to.equal(1);
        });
      });

      describe('onAfterLeave', () => {
        it('should be called with 3 arguments: [location, commands, router]', async() => {
          const onAfterLeave = sinon.spy();
          router.setRoutes([
            {path: '/', action: onAfterLeaveAction('x-home-view', onAfterLeave)},
            {path: '/users', component: 'x-users-list'}
          ]);

          await router.render('/');

          expect(onAfterLeave).not.to.have.been.called;

          await router.render('/users');

          expect(onAfterLeave).to.have.been.called.once;
          expect(onAfterLeave.args[0].length).to.equal(3);

          const location = onAfterLeave.args[0][0];
          expect(location.pathname).to.equal('/users');
          expect(location.route.path).to.equal('/users');

          const commands = onAfterLeave.args[0][1];
          expect(commands).to.be.an('object').that.is.not.null;
          expect(commands.prevent).to.not.be.defined;
          expect(commands.redirect).to.not.be.defined;
          expect(commands.component).to.not.be.defined;

          const routerArg = onAfterLeave.args[0][2];
          expect(routerArg).to.equal(router);

          expect(outlet.children[0].tagName).to.match(/x-users-list/i);
        });

        it('should be called on the route web component instance (as `this`)', async() => {
          const onAfterLeave = sinon.spy();
          router.setRoutes([
            {path: '/', action: onAfterLeaveAction('x-home-view', onAfterLeave)},
            {path: '/users', component: 'x-users-list'}
          ]);

          await router.render('/');
          const homeViewElement = outlet.children[0];

          await router.render('/users');

          expect(onAfterLeave).to.have.been.calledOn(homeViewElement);
          expect(outlet.children[0].tagName).to.match(/x-users-list/i);
        });

        it('should ignore all return values', async() => {
          const values = [
            true,
            false,
            0,
            42,
            [],
            {not_a_redirect: true},
            {redirect: {pathname: '/'}},
            {cancel: true},
            null,
            undefined,
            () => true,
            'random-tag-name',
            document.createElement('div'),
          ];

          for (let i = 0; i < values.length; i += 1) {
            const onAfterLeave = sinon.stub().returns(values[i]);
            router.setRoutes([
              {path: '/', action: onAfterLeaveAction('x-home-view', onAfterLeave)},
              {path: '/users', component: 'x-users-list'},
            ]);

            await router.render('/');
            await router.render('/users');
            expect(outlet.children[0].tagName).to.match(/x-users-list/i);
            verifyActiveRoutes(router, ['/users']);
          }
        });
      });

      describe('onAfterEnter', () => {
        it('should be called with 3 argument: [location, commands, router]', async() => {
          const onAfterEnter = sinon.spy();
          router.setRoutes([
            {path: '/', action: onAfterEnterAction('x-home-view', onAfterEnter)}
          ]);

          await router.render('/');

          expect(onAfterEnter).to.have.been.called.once;
          expect(onAfterEnter.args[0].length).to.equal(3);

          const location = onAfterEnter.args[0][0];
          expect(location.pathname).to.equal('/');
          expect(location.route.path).to.equal('/');

          const commands = onAfterEnter.args[0][1];
          expect(commands).to.be.an('object').that.is.not.null;
          expect(commands.prevent).to.not.be.defined;
          expect(commands.redirect).to.not.be.defined;
          expect(commands.component).to.not.be.defined;

          const routerArg = onAfterEnter.args[0][2];
          expect(routerArg).to.equal(router);

          expect(outlet.children[0].tagName).to.match(/x-home-view/i);
        });

        it('should be called on the route web component instance (as `this`)', async() => {
          const onAfterEnter = sinon.spy();
          router.setRoutes([
            {path: '/', action: onAfterEnterAction('x-home-view', onAfterEnter)},
          ]);

          await router.render('/');

          expect(onAfterEnter).to.have.been.calledOn(outlet.children[0]);
          expect(outlet.children[0].tagName).to.match(/x-home-view/i);
        });

        it('should ignore all return values', async() => {
          const values = [
            true,
            false,
            0,
            42,
            [],
            {not_a_redirect: true},
            {redirect: {pathname: '/'}},
            {cancel: true},
            null,
            undefined,
            () => true,
            'random-tag-name',
            document.createElement('div'),
          ];

          for (let i = 0; i < values.length; i += 1) {
            const onAfterEnter = sinon.stub().returns(values[i]);
            router.setRoutes([
              {path: '/', action: onAfterEnterAction('x-home-view', onAfterEnter)},
              {path: '/users', component: 'x-users-list'},
            ]);

            await router.render('/');
            await router.render('/users');
            expect(outlet.children[0].tagName).to.match(/x-users-list/i);
            verifyActiveRoutes(router, ['/users']);
          }
        });
      });

      describe('the order of lifecycle events (without early returns)', () => {
        it('(initial) -> /a', async() => {
          router.setRoutes([
            {path: '/a', action: elementWithAllLifecycleCallbacks('a')},
          ]);

          await router.render('/').catch(() => {});
          callbacksLog = [];
          await router.render('/a');

          verifyCallbacks([
            'a.action',
            'undefined.location setter',
            'a.onBeforeEnter',
            'a.connectedCallback',
            'a.onAfterEnter',
          ]);
        });

        it('/a -> /b', async() => {
          router.setRoutes([
            {path: '/a', action: elementWithAllLifecycleCallbacks('a')},
            {path: '/b', action: elementWithAllLifecycleCallbacks('b')},
          ]);

          await router.render('/a');
          callbacksLog = [];
          await router.render('/b');

          verifyCallbacks([
            'b.action',
            'undefined.location setter',
            'a.onBeforeLeave',
            'b.onBeforeEnter',
            'b.connectedCallback',
            'b.onAfterEnter',
            'a.onAfterLeave',
            'a.disconnectedCallback',
          ]);
        });

        it('(initial) -> /a/b', async() => {
          router.setRoutes([
            {
              path: '/a',
              action: () => {
                callbacksLog.push('a.action');
              },
              children: [
                {path: '/b', action: elementWithAllLifecycleCallbacks('b')},
              ]
            },
          ]);

          await router.render('/').catch(() => {});
          callbacksLog = [];
          await router.render('/a/b');

          verifyCallbacks([
            'a.action',
            'b.action',
            'undefined.location setter',
            'b.onBeforeEnter',
            'b.connectedCallback',
            'b.onAfterEnter',
          ]);
        });

        it('/a/b -> /a/c', async() => {
          router.setRoutes([
            {
              path: '/a',
              action: () => {
                callbacksLog.push('a.action');
              },
              children: [
                {path: '/b', action: elementWithAllLifecycleCallbacks('b')},
                {path: '/c', action: elementWithAllLifecycleCallbacks('c')},
              ]
            },
          ]);

          await router.render('/a/b');
          callbacksLog = [];
          await router.render('/a/c');

          verifyCallbacks([
            'a.action',
            'c.action',
            'undefined.location setter',
            'b.onBeforeLeave',
            'c.onBeforeEnter',
            'c.connectedCallback',
            'c.onAfterEnter',
            'b.onAfterLeave',
            'b.disconnectedCallback',
          ]);
        });

        it('(initial) -> /a/non-existent-path', async() => {
          await router.render('/').catch(() => {});
          callbacksLog = [];

          // call 'setRoutes' without triggering a navigation event
          Vaadin.Resolver.prototype.setRoutes.call(router, [
            {
              path: '/a',
              action: () => {
                callbacksLog.push('a.action');
              },
              children: [
                {path: '/b', action: elementWithAllLifecycleCallbacks('b')},
              ]
            },
            {path: '(.*)', action: elementWithAllLifecycleCallbacks('asterisk')},
          ]);
          await router.render('/a/non-existent-path');

          verifyCallbacks([
            'a.action',
            'asterisk.action',
            'undefined.location setter',
            'asterisk.onBeforeEnter',
            'asterisk.connectedCallback',
            'asterisk.onAfterEnter',
          ]);
        });

        it('/a/b -> /a/non-existent-path', async() => {
          router.setRoutes([
            {
              path: '/a',
              action: () => {
                callbacksLog.push('a.action');
              },
              children: [
                {path: '/b', action: elementWithAllLifecycleCallbacks('b')},
              ]
            },
            {path: '(.*)', action: elementWithAllLifecycleCallbacks('asterisk')},
          ]);

          await router.render('/a/b');
          callbacksLog = [];
          await router.render('/a/non-existent-path');

          verifyCallbacks([
            'a.action',
            'asterisk.action',
            'undefined.location setter',
            'b.onBeforeLeave',
            'asterisk.onBeforeEnter',
            'asterisk.connectedCallback',
            'asterisk.onAfterEnter',
            'b.onAfterLeave',
            'b.disconnectedCallback',
          ]);
        });

        it('/a/c -> /a/d (/a gets visited, but does not get matched)', async() => {
          router.setRoutes([
            {
              path: '/a',
              action: () => {
                callbacksLog.push('a.action');
              },
              children: [
                {
                  path: '/b',
                  action: () => {
                    callbacksLog.push('b.action');
                  },
                  component: 'x-spy'},
              ]
            },
            {path: '/a/c', action: elementWithAllLifecycleCallbacks('ac')},
            {path: '/a/d', action: elementWithAllLifecycleCallbacks('ad')},
          ]);

          await router.render('/a/c');
          callbacksLog = [];
          await router.render('/a/d');

          verifyCallbacks([
            'a.action',
            'ad.action',
            'undefined.location setter',
            'ac.onBeforeLeave',
            'ad.onBeforeEnter',
            'ad.connectedCallback',
            'ad.onAfterEnter',
            'ac.onAfterLeave',
            'ac.disconnectedCallback',
          ]);
        });

        it('/users/jane -> /users/john (when parameters are changed, all callbacks are not called again, only location setters are)', async() => {
          router.setRoutes([
            {path: '/users/:user', action: elementWithUserParameter()}
          ]);

          await router.render('/users/jane');
          callbacksLog = [];
          await router.render('/users/john');

          verifyCallbacks([
            'x-user-john.action',
            'undefined.location setter',
            'x-user-jane.location setter',
          ]);
        });
      });

      describe('lifecycle events for nested routes', () => {
        const {checkOutletContents} = VaadinTestNamespace;
        const checkOutlet = values => checkOutletContents(outlet.children[0], 'name', values);

        beforeEach(async function() {
          router.setRoutes([
            {path: '/a', action: elementWithAllLifecycleCallbacks('x-a'), children: [
              {path: '/b', action: elementWithAllLifecycleCallbacks('x-b'), children: [
                {path: '/e', action: elementWithAllLifecycleCallbacks('x-e')}
              ]},
              {path: '/d', action: elementWithAllLifecycleCallbacks('x-d')}
            ]},
            {path: '/c', action: elementWithAllLifecycleCallbacks('x-c')}
          ]);
          callbacksLog = [];
        });

        it('/a/b -> /a/b', async() => {
          await router.render('/a/b');

          verifyCallbacks([
            'x-a.action',
            'undefined.location setter',
            'x-b.action',
            'undefined.location setter',
            'x-a.onBeforeEnter',
            'x-b.onBeforeEnter',
            'x-a.connectedCallback',
            'x-b.connectedCallback',
            'x-a.onAfterEnter',
            'x-b.onAfterEnter',
          ]);
          checkOutlet(['x-a', 'x-b']);

          callbacksLog = [];
          await router.render('/a/b');

          verifyCallbacks([
            'x-a.action',
            'undefined.location setter',
            'x-b.action',
            'undefined.location setter',
            'x-a.location setter',
            'x-b.location setter',
          ]);
          checkOutlet(['x-a', 'x-b']);
        });

        it('/a/b -> /c', async() => {
          await router.render('/a/b');

          verifyCallbacks([
            'x-a.action',
            'undefined.location setter',
            'x-b.action',
            'undefined.location setter',
            'x-a.onBeforeEnter',
            'x-b.onBeforeEnter',
            'x-a.connectedCallback',
            'x-b.connectedCallback',
            'x-a.onAfterEnter',
            'x-b.onAfterEnter',
          ]);
          checkOutlet(['x-a', 'x-b']);

          callbacksLog = [];
          await router.render('/c');

          verifyCallbacks([
            'x-c.action',
            'undefined.location setter',
            'x-b.onBeforeLeave',
            'x-a.onBeforeLeave',
            'x-c.onBeforeEnter',
            'x-c.connectedCallback',
            'x-c.onAfterEnter',
            'x-b.onAfterLeave',
            'x-a.onAfterLeave',
            'x-b.disconnectedCallback',
            'x-a.disconnectedCallback',
          ]);
          checkOutlet(['x-c']);
        });

        it('/a/b -> /a/d', async() => {
          await router.render('/a/b');

          verifyCallbacks([
            'x-a.action',
            'undefined.location setter',
            'x-b.action',
            'undefined.location setter',
            'x-a.onBeforeEnter',
            'x-b.onBeforeEnter',
            'x-a.connectedCallback',
            'x-b.connectedCallback',
            'x-a.onAfterEnter',
            'x-b.onAfterEnter',
          ]);
          checkOutlet(['x-a', 'x-b']);

          callbacksLog = [];
          await router.render('/a/d');

          verifyCallbacks([
            'x-a.action',
            'undefined.location setter',
            'x-d.action',
            'undefined.location setter',
            'x-a.location setter',
            'x-b.onBeforeLeave',
            'x-d.onBeforeEnter',
            'x-d.connectedCallback',
            'x-d.onAfterEnter',
            'x-b.onAfterLeave',
            'x-b.disconnectedCallback',
          ]);
          checkOutlet(['x-a', 'x-d']);
        });

        it('/a/b -> /a/b/e', async() => {
          await router.render('/a/b');

          verifyCallbacks([
            'x-a.action',
            'undefined.location setter',
            'x-b.action',
            'undefined.location setter',
            'x-a.onBeforeEnter',
            'x-b.onBeforeEnter',
            'x-a.connectedCallback',
            'x-b.connectedCallback',
            'x-a.onAfterEnter',
            'x-b.onAfterEnter',
          ]);
          checkOutlet(['x-a', 'x-b']);

          callbacksLog = [];
          await router.render('/a/b/e');

          verifyCallbacks([
            'x-a.action',
            'undefined.location setter',
            'x-b.action',
            'undefined.location setter',
            'x-e.action',
            'undefined.location setter',
            'x-a.location setter',
            'x-b.location setter',
            'x-e.onBeforeEnter',
            'x-e.connectedCallback',
            'x-e.onAfterEnter',
          ]);
          checkOutlet(['x-a', 'x-b', 'x-e']);
        });

        it('/a/b -> /a/b/e with extra root path', async() => {
          router.setRoutes([
            {path: '/a', action: elementWithAllLifecycleCallbacks('x-a'), children: [
              {path: '/b', action: elementWithAllLifecycleCallbacks('x-b'), children: [
                {path: '/', action: elementWithAllLifecycleCallbacks('x-b-root')},
                {path: '/e', action: elementWithAllLifecycleCallbacks('x-e')}
              ]},
              {path: '/d', action: elementWithAllLifecycleCallbacks('x-d')}
            ]},
            {path: '/c', action: elementWithAllLifecycleCallbacks('x-c')}
          ]);

          callbacksLog = [];
          await router.render('/a/b');

          verifyCallbacks([
            'x-a.action',
            'undefined.location setter',
            'x-b.action',
            'undefined.location setter',
            'x-b-root.action',
            'undefined.location setter',
            'x-a.onBeforeEnter',
            'x-b.onBeforeEnter',
            'x-b-root.onBeforeEnter',
            'x-a.connectedCallback',
            'x-b.connectedCallback',
            'x-b-root.connectedCallback',
            'x-a.onAfterEnter',
            'x-b.onAfterEnter',
            'x-b-root.onAfterEnter',
          ]);
          checkOutlet(['x-a', 'x-b', 'x-b-root']);

          callbacksLog = [];
          await router.render('/a/b/e');

          verifyCallbacks([
            'x-a.action',
            'undefined.location setter',
            'x-b.action',
            'undefined.location setter',
            'x-e.action',
            'undefined.location setter',
            'x-a.location setter',
            'x-b.location setter',
            'x-b-root.onBeforeLeave',
            'x-e.onBeforeEnter',
            'x-e.connectedCallback',
            'x-e.onAfterEnter',
            'x-b-root.onAfterLeave',
            'x-b-root.disconnectedCallback',
          ]);
          checkOutlet(['x-a', 'x-b', 'x-e']);
        });

        it('/a/b/e -> /a/b', async() => {
          await router.render('/a/b/e');

          verifyCallbacks([
            'x-a.action',
            'undefined.location setter',
            'x-b.action',
            'undefined.location setter',
            'x-e.action',
            'undefined.location setter',
            'x-a.onBeforeEnter',
            'x-b.onBeforeEnter',
            'x-e.onBeforeEnter',
            'x-a.connectedCallback',
            'x-b.connectedCallback',
            'x-e.connectedCallback',
            'x-a.onAfterEnter',
            'x-b.onAfterEnter',
            'x-e.onAfterEnter',
          ]);
          checkOutlet(['x-a', 'x-b', 'x-e']);

          callbacksLog = [];
          await router.render('/a/b');

          verifyCallbacks([
            'x-a.action',
            'undefined.location setter',
            'x-b.action',
            'undefined.location setter',
            'x-a.location setter',
            'x-b.location setter',
            'x-e.onBeforeLeave',
            'x-e.onAfterLeave',
            'x-e.disconnectedCallback',
          ]);
          checkOutlet(['x-a', 'x-b']);
        });

        it('/a/b/e -> /a/b with extra root path', async() => {
          router.setRoutes([
            {path: '/a', action: elementWithAllLifecycleCallbacks('x-a'), children: [
              {path: '/b', action: elementWithAllLifecycleCallbacks('x-b'), children: [
                {path: '/', action: elementWithAllLifecycleCallbacks('x-b-root')},
                {path: '/e', action: elementWithAllLifecycleCallbacks('x-e')}
              ]},
              {path: '/d', action: elementWithAllLifecycleCallbacks('x-d')}
            ]},
            {path: '/c', action: elementWithAllLifecycleCallbacks('x-c')}
          ]);

          callbacksLog = [];
          await router.render('/a/b/e');

          verifyCallbacks([
            'x-a.action',
            'undefined.location setter',
            'x-b.action',
            'undefined.location setter',
            'x-e.action',
            'undefined.location setter',
            'x-a.onBeforeEnter',
            'x-b.onBeforeEnter',
            'x-e.onBeforeEnter',
            'x-a.connectedCallback',
            'x-b.connectedCallback',
            'x-e.connectedCallback',
            'x-a.onAfterEnter',
            'x-b.onAfterEnter',
            'x-e.onAfterEnter',
          ]);
          checkOutlet(['x-a', 'x-b', 'x-e']);

          callbacksLog = [];
          await router.render('/a/b');

          verifyCallbacks([
            'x-a.action',
            'undefined.location setter',
            'x-b.action',
            'undefined.location setter',
            'x-b-root.action',
            'undefined.location setter',
            'x-a.location setter',
            'x-b.location setter',
            'x-e.onBeforeLeave',
            'x-b-root.onBeforeEnter',
            'x-b-root.connectedCallback',
            'x-b-root.onAfterEnter',
            'x-e.onAfterLeave',
            'x-e.disconnectedCallback',
          ]);
          checkOutlet(['x-a', 'x-b', 'x-b-root']);
        });

        it('lifecycle events work for routes added via children function', async() => {
          router.setRoutes([
            {path: '/a', component: 'x-a', children: () => [
              {path: '/b', action: elementWithAllLifecycleCallbacks('x-b')},
            ]},
            {path: '/c', component: 'x-c'}
          ]);

          callbacksLog = [];
          await router.render('/a/b');

          verifyCallbacks([
            'x-b.action',
            'undefined.location setter',
            'x-b.onBeforeEnter',
            'x-b.connectedCallback',
            'x-b.onAfterEnter',
          ]);

          callbacksLog = [];
          await router.render('/c');

          verifyCallbacks([
            'x-b.onBeforeLeave',
            'x-b.onAfterLeave',
            'x-b.disconnectedCallback',
          ]);
        });

        it('/users/jane/edit -> /users/john/edit (when parameters changed, callbacks for nested routes are not called, only location setter is)', async() => {
          router.setRoutes([
            {path: '/users', action: elementWithAllLifecycleCallbacks('x-users'), children: [
              {path: '/:user', action: elementWithUserParameter(), children: [
                {path: '/edit', action: elementWithAllLifecycleCallbacks('x-user-edit')}
              ]}
            ]}
          ]);

          await router.render('/users/jane/edit');
          verifyCallbacks([
            'x-users.action',
            'undefined.location setter',
            'x-user-jane.action',
            'undefined.location setter',
            'x-user-edit.action',
            'undefined.location setter',
            'x-users.onBeforeEnter',
            'x-user-jane.onBeforeEnter',
            'x-user-edit.onBeforeEnter',
            'x-users.connectedCallback',
            'x-user-jane.connectedCallback',
            'x-user-edit.connectedCallback',
            'x-users.onAfterEnter',
            'x-user-jane.onAfterEnter',
            'x-user-edit.onAfterEnter',
          ]);

          callbacksLog = [];
          await router.render('/users/john/edit');

          verifyCallbacks([
            'x-users.action',
            'undefined.location setter',
            'x-user-john.action',
            'undefined.location setter',
            'x-user-edit.action',
            'undefined.location setter',
            'x-users.location setter',
            'x-user-jane.location setter',
            'x-user-edit.location setter',
          ]);
        });
      });

      describe('lifecycle events with bundle', () => {
        const existingBundlePath = encodeURI('data:application/javascript,callbacksLog.push("bundle");//.js');
        function getBundleScript() {
          return document.head.querySelector('script[src="' + existingBundlePath + '"][async]');
        }
        afterEach(() => {
          const bundleScript = getBundleScript();
          if (bundleScript) {
            bundleScript.parentNode.removeChild(bundleScript);
          }
        });

        it('should invoke lifecycle events after bundle loading is complete', async() => {
          router.setRoutes([
            {path: '/', component: 'x-home-view'},
            {path: '/x-spy', bundle: existingBundlePath, component: 'x-spy'}
          ]);

          await router.render('/');
          callbacksLog = [];
          await router.render('/x-spy');

          verifyCallbacks([
            'bundle',
            'undefined.location setter',
            'undefined.onBeforeEnter',
            'undefined.connectedCallback',
            'undefined.onAfterEnter'
          ]);
        });
      });

      describe('lifecycle events with async action', () => {
        it('should invoke lifecycle events after action promise resolves', async() => {
          router.setRoutes([
            {path: '/', component: 'x-home-view'},
            {path: '/x-spy', action: (context, commands) => {
              return new Promise(resolve => {
                setTimeout(() => {
                  callbacksLog.push('action.promise');
                  resolve();
                }, 100);
              });
            }, component: 'x-spy'}
          ]);

          await router.render('/');
          callbacksLog = [];
          await router.render('/x-spy');

          verifyCallbacks([
            'action.promise',
            'undefined.location setter',
            'undefined.onBeforeEnter',
            'undefined.connectedCallback',
            'undefined.onAfterEnter'
          ]);
        });
      });

      describe('the global `vaadin-router-location-changed` event', () => {
        it('should be triggered after a completed navigation', async() => {
          router.setRoutes([
            {path: '/', component: 'x-home-view'},
          ]);

          const onRouteChanged = sinon.spy();
          window.addEventListener('vaadin-router-location-changed', onRouteChanged);
          await router.render('/');
          window.removeEventListener('vaadin-router-location-changed', onRouteChanged);

          expect(onRouteChanged).to.have.been.called.once;
        });

        it('should NOT be triggered after an abandoned navigation', async() => {
          router.setRoutes([
            {path: '/', component: 'x-home-view'},
            {path: '/admin', component: 'x-admin-view'},
          ]);

          const onRouteChanged = sinon.spy();
          window.addEventListener('vaadin-router-location-changed', onRouteChanged);
          await Promise.all([
            router.render('/'),
            router.render('/admin')
          ]);
          window.removeEventListener('vaadin-router-location-changed', onRouteChanged);

          expect(onRouteChanged).to.have.been.called.once;
        });

        it('should contain the new location as `event.detail.location`', async() => {
          router.setRoutes([
            {path: '/admin', component: 'x-admin-view'},
          ]);

          const onRouteChanged = sinon.spy();
          window.addEventListener('vaadin-router-location-changed', onRouteChanged);
          await router.render('/admin');
          window.removeEventListener('vaadin-router-location-changed', onRouteChanged);

          expect(onRouteChanged).to.have.been.called.once;
          expect(onRouteChanged.args[0].length).to.equal(1);

          const event = onRouteChanged.args[0][0];
          expect(event.detail.location).to.equal(router.location);
        });

        it('should contain the router instance as `event.detail.router`', async() => {
          router.setRoutes([
            {path: '/admin', component: 'x-admin-view'},
          ]);

          const onRouteChanged = sinon.spy();
          window.addEventListener('vaadin-router-location-changed', onRouteChanged);
          await router.render('/admin');
          window.removeEventListener('vaadin-router-location-changed', onRouteChanged);

          expect(onRouteChanged).to.have.been.called.once;
          expect(onRouteChanged.args[0].length).to.equal(1);

          const event = onRouteChanged.args[0][0];
          expect(event.detail.router).to.equal(router);
        });
      });

      describe('the global `vaadin-router-error` event', () => {
        it('should be triggered after a failed navigation', async() => {
          router.setRoutes([
            {path: '/', component: 'x-home-view'},
          ]);

          const onError = sinon.spy();
          window.addEventListener('vaadin-router-error', onError);
          await router.render('/non-existent').catch(() => {});
          window.removeEventListener('vaadin-router-error', onError);

          expect(onError).to.have.been.called.once;
        });

        it('should NOT be triggered after an abandoned navigation', async() => {
          router.setRoutes([
            {path: '/', component: 'x-home-view'},
          ]);

          const onError = sinon.spy();
          window.addEventListener('vaadin-router-error', onError);
          await Promise.all([
            router.render('/non-existent-1').catch(() => {}),
            router.render('/non-existent-2').catch(() => {}),
          ]);
          window.removeEventListener('vaadin-router-error', onError);

          expect(onError).to.have.been.called.once;
        });

        it('should contain the error as `event.detail.error`', async() => {
          router.setRoutes([
            {path: '/', component: 'x-home-view'},
          ]);

          const onError = sinon.spy();
          window.addEventListener('vaadin-router-error', onError);
          await router.render('/non-existent').catch(() => {});
          window.removeEventListener('vaadin-router-error', onError);

          expect(onError).to.have.been.called.once;
          expect(onError.args[0].length).to.equal(1);

          const event = onError.args[0][0];
          expect(event.detail.error).to.be.an('error');
          expect(event.detail.error.context.pathname).to.equal('/non-existent');
        });

        it('should contain the router instance as `event.detail.router`', async() => {
          router.setRoutes([
            {path: '/', component: 'x-home-view'},
          ]);

          const onError = sinon.spy();
          window.addEventListener('vaadin-router-error', onError);
          await router.render('/non-existent').catch(() => {});
          window.removeEventListener('vaadin-router-error', onError);

          expect(onError).to.have.been.called.once;
          expect(onError.args[0].length).to.equal(1);

          const event = onError.args[0][0];
          expect(event.detail.router).to.equal(router);
        });

        it('should contain the failed pathname as `event.detail.pathname`', async() => {
          router.setRoutes([
            {path: '/', component: 'x-home-view'},
          ]);

          const onError = sinon.spy();
          window.addEventListener('vaadin-router-error', onError);
          await router.render('/non-existent').catch(() => {});
          window.removeEventListener('vaadin-router-error', onError);

          expect(onError).to.have.been.called.once;
          expect(onError.args[0].length).to.equal(1);

          const event = onError.args[0][0];
          expect(event.detail.pathname).to.equal('/non-existent');
        });
      });
    });
  </script>
</body>
