<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>router.spec</title>
  <script src="../../bower_components/web-component-tester/browser.js"></script>
  <script src="../../bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../dist/vaadin-router.umd.js"></script>
  <script src="test-utils.js"></script>

  <link rel="import" href="../test-pushstate-throttler.html">
</head>

<body>
  <test-pushstate-throttler id="throttler"></test-pushstate-throttler>
  <a id="admin-anchor" href="/admin"></a>
  <test-fixture id="outlet">
    <template>
      <div></div>
    </template>
  </test-fixture>

  <script>
    describe('Vaadin.Router', function() {
      // eslint-disable-next-line no-invalid-this
      this.title = this.title + (window.ShadyDOM ? ' (Shady DOM)' : '');

      const {checkOutletContents} = VaadinTestNamespace;
      const checkOutlet = values => checkOutletContents(outlet.children[0], 'tagName', values);

      let outlet;
      beforeEach(() => {
        // reset the URL
        window.history.pushState(null, null, '/');

        // stamp the test fixture DOM into the page
        outlet = fixture('outlet');
      });

      const throttler = document.querySelector('#throttler');
      afterEach(function() {
        const test = this; // eslint-disable-line no-invalid-this
        return throttler.throttle(test);
      });

      describe('JS API (basic functionality)', () => {
        describe('new Router(outlet?, options?)', () => {
          it('should work without arguments', () => {
            const router = new Vaadin.Router();
            expect(router).to.be.ok;
          });

          it('should accept a router outlet DOM Node as the 1st argument', () => {
            const router = new Vaadin.Router(outlet);
            const actual = router.getOutlet();
            expect(actual).to.equal(outlet);
          });

          it('should throw if the router outlet is truthy but is not valid a DOM Node', () => {
            [
              true,
              42,
              '<slot></slot>',
              {},
              [document.body],
              () => document.body
            ].forEach(arg => {
              expect(() => new Vaadin.Router(arg), `${arg}`).to.throw(TypeError);
            });
          });

          it('route should throw when created with only path property', () => {
            const router = new Vaadin.Router(outlet);
            expect(() => router.setRoutes([{path: '/'}])).to.throw(Error);
          });

          it('route should throw when created with unknown bundle type', () => {
            const router = new Vaadin.Router(outlet);
            expect(() => router.setRoutes([{path: '/', bundle: () => {}}])).to.throw(Error);
          });

          it('route should throw when created with bundle object without required keys', () => {
            const router = new Vaadin.Router(outlet);
            expect(() => router.setRoutes([{path: '/', bundle: {}}])).to.throw(Error);
          });

          it('route should throw when created with unknown bundle extension', () => {
            const router = new Vaadin.Router(outlet);
            expect(() => router.setRoutes([{path: '/', bundle: 'test.html'}])).to.throw(Error);
          });

          it('route should throw when created with bundle object having keys with unknown extension', () => {
            const router = new Vaadin.Router(outlet);
            expect(() => router.setRoutes([{path: '/', bundle: {module: 'test.html'}}])).to.throw(Error);
          });

          it('should accept an options object as the 2nd argument', () => {
            const router = new Vaadin.Router(null, {baseUrl: '/users'});
            expect(router).to.have.property('baseUrl', '/users');
          });

          it('should not fail silently if not configured (both routes and outlet missing)', async() => {
            const router = new Vaadin.Router();
            const onError = sinon.spy();
            const link = document.getElementById('admin-anchor');
            link.click();
            await router.ready.catch(onError);

            expect(onError).to.have.been.called.once;

            const error = onError.args[0][0];
            expect(error).to.be.an('error');
            expect(error.message).to.match(/page not found/i);
          });

          it('should not fail silently if not configured (outlet is set but routes are missing)', async() => {
            const router = new Vaadin.Router(outlet);
            const onError = sinon.spy();
            const link = document.getElementById('admin-anchor');
            link.click();
            await router.ready.catch(onError);

            expect(onError).to.have.been.called.once;

            const error = onError.args[0][0];
            expect(error).to.be.an('error');
            expect(error.message).to.match(/page not found/i);
          });
        });

        describe('router.render(pathname)', () => {
          const add100msDelay = () => {
            return new Promise((resolve, reject) => {
              setTimeout(() => resolve(), 100);
            });
          };

          let router;
          beforeEach(() => {
            router = new Vaadin.Router(outlet);
          });

          afterEach(() => {
            router.unsubscribe();
          });

          it('should throw if the router outlet is a not valid DOM Node (on finish)', async() => {
            await Promise.all([
              undefined,
              null,
              0,
              false,
              '',
              NaN
            ].map(async(invalidOutlet) => {
              const router = new Vaadin.Router(outlet);
              router.setRoutes([{path: '/', component: 'x-home-view'}]);
              const fulfilled = sinon.spy();
              const rejected = sinon.spy();
              const ready = router.render('/').then(fulfilled).catch(rejected);
              router.setOutlet(invalidOutlet);
              await ready;
              expect(fulfilled).to.not.have.been.called;
              expect(rejected).to.have.been.called.once;
              expect(rejected.args[0][0]).to.be.instanceof(TypeError);
              router.unsubscribe();
            }));
          });

          it('should return a promise that resolves to the router outlet DOM element', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            const result = router.render('/');
            expect(result).to.be.a('promise');
            const actual = await result;
            expect(actual).to.equal(outlet);
          });

          it('should return a promise that resolves when the rendered content is appended to the DOM', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            const promise = router.render('/');
            expect(outlet.children).to.have.lengthOf(0);
            await promise;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should return a promise that gets rejected on no-match', (done) => {
            const result = router.render('/path/not/defined');
            result
              .then(() => {
                throw new Error('the promise should have been rejected');
              })
              .catch(() => done());
          });

          it('should create and append a route `component` into the router outlet', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            await router.render('/');
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should rethrow DOMException if the route `component` is not a valid tag name', async() => {
            router.setRoutes([{path: '/', component: 'src/x-home-view'}]);
            const fulfilled = sinon.spy();
            const rejected = sinon.spy();
            const ready = router.render('/').then(fulfilled).catch(rejected);
            await ready;
            expect(fulfilled).to.not.have.been.called;
            expect(rejected).to.have.been.called.once;
            expect(rejected.args[0][0]).to.be.instanceof(DOMException);
          });

          it('should replace any pre-existing content of the router outlet', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/users', component: 'x-users-view'},
            ]);
            await router.render('/');
            await router.render('/users');
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-users-view/i);
          });

          it('should remove any pre-existing content of the router outlet on no-match', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            await router.render('/');

            await router.render('/path/not/defined').catch(() => {});
            expect(outlet.children).to.have.lengthOf(0);
          });

          it('should ignore a successful result of a resolve pass if a new resolve pass is started before the first is completed', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/slow', action: add100msDelay, children: [
                {path: '/users', component: 'x-users-view'},
              ]},
              {path: '/admin', component: 'x-admin-view'},
            ]);
            await Promise.all([
              router.render('/slow/users'), // start the first resolve pass
              router.render('/admin'), // start the second resolve pass before the first is completed
            ]);
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-admin-view/i);
          });

          it('should ignore an error result of a resolve pass if a new resolve pass is started before the first is completed', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/slow', action: add100msDelay, children: [
                {path: '/users', component: 'x-users-view'},
              ]},
              {path: '/admin', component: 'x-admin-view'},
            ]);
            await Promise.all([
              router.render('/slow/non-existent').catch(() => {}), // start the first resolve pass
              router.render('/admin'), // start the second resolve pass before the first is completed
            ]);
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-admin-view/i);
          });

          it('should start a new resolve pass when route has "redirect" property', async() => {
            const from = '/people';
            const pathname = '/users';
            const result = {redirect: {pathname, from, params: {}}};

            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/people', redirect: '/users'},
              {path: '/users', component: 'x-users-view'},
            ]);
            const spy = sinon.spy(router, 'resolve');
            await router.render(from);

            expect(spy).to.be.calledTwice;
            const firstResult = await spy.returnValues[0];
            expect(firstResult.result).to.deep.equal(result);

            expect(spy.secondCall.args[0].redirectFrom).to.equal(from);
            expect(spy.secondCall.args[0].pathname).to.equal(pathname);
          });

          it('should handle multiple redirects', async() => {
            router.setRoutes([
              {path: '/a', redirect: '/b'},
              {path: '/b', redirect: '/c'},
              {path: '/c', component: 'x-home-view'},
            ]);

            await router.render('/a');

            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should fail on recursive redirects', async() => {
            router.setRoutes([
              {path: '/a', redirect: '/b'},
              {path: '/b', redirect: '/c'},
              {path: '/c', redirect: '/a'},
            ]);

            const onError = sinon.spy();
            await router.render('/a').catch(onError);

            expect(outlet.children).to.have.lengthOf(0);
            expect(onError).to.have.been.called.once;
          });

          it('should render a component for the new route when redirecting', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/people', redirect: '/users'},
              {path: '/users', component: 'x-users-view'},
            ]);
            await router.render('/people');
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-users-view/i);
          });

          it('should use `window.replaceState()` when redirecting', async() => {
            const pushSpy = sinon.spy(window.history, 'pushState');
            const replaceSpy = sinon.spy(window.history, 'replaceState');
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/people', redirect: '/users'},
              {path: '/users', component: 'x-users-view'},
            ]);
            await router.render('/people', true);
            expect(pushSpy).to.not.be.called;
            expect(replaceSpy).to.be.calledOnce;
          });

          it('should set the `location.redirectFrom` property on the route component in case of redirect', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/people', redirect: '/users'},
              {path: '/users', component: 'x-users-view'},
            ]);
            await router.render('/people');
            expect(outlet.children[0]).to.have.deep.property('location.redirectFrom', '/people');
          });
        });

        describe('router.ready', () => {
          let router;
          beforeEach(() => {
            router = new Vaadin.Router(outlet);
          });

          afterEach(() => {
            router.unsubscribe();
          });

          it('should be a promise', () => {
            expect(router).to.have.property('ready')
              .that.is.a('promise');
          });

          it('(render in progress / ok) should get fulfilled after the render is completed', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            router.render('/');
            await router.ready.then((outlet) => {
              expect(outlet.children).to.have.lengthOf(1);
              expect(outlet.children[0].tagName).to.match(/x-home-view/i);
            });
          });

          it('(render in progress / error) should get rejected with the current render error', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            router.render('non-existent-path');
            await router.ready.then(() => {
              throw new Error('the `ready` promise should have been rejected');
            }).catch((error) => {
              expect(outlet.children).to.have.lengthOf(0);
              expect(error).to.be.an('error');
              expect(error).to.have.property('code', 404);
              expect(error).to.have.property('message')
                .that.matches(/non-existent-path/);
            });
          });

          it('(render completed / ok) should get fulfilled with the last render result', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            await router.render('/').then(() => {
              return router.ready.then((outlet) => {
                expect(outlet.children).to.have.lengthOf(1);
                expect(outlet.children[0].tagName).to.match(/x-home-view/i);
              });
            });
          });

          it('(render completed / error) should get rejected with the last render error', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            await router.render('non-existent-path').catch(() => {
              return router.ready.then((outlet) => {
                throw new Error('the `ready` promise should have been rejected');
              }).catch((error) => {
                expect(error).to.be.an('error');
                expect(error).to.have.property('code', 404);
                expect(error).to.have.property('message')
                  .that.matches(/non-existent-path/);
              });
            });
          });

          it('(no renders yet) should get fulfilled before the first render completes', async() => {
            const sequence = [];
            const p1 = router.ready.then(() => {
              expect(outlet.children).to.have.lengthOf(0);
              sequence.push('no render yet');
            });

            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            const p2 = router.render('/').then(() => {
              expect(outlet.children).to.have.lengthOf(1);
              sequence.push('first render done');
            });

            await Promise.all([p1, p2]).then(() => {
              expect(sequence[0]).to.equal('no render yet');
              expect(sequence[1]).to.equal('first render done');
            });
          });
        });

        describe('router.location', () => {
          let router;
          beforeEach(() => {
            router = new Vaadin.Router(outlet);
          });

          afterEach(() => {
            router.unsubscribe();
          });

          it('should be a non-null object', () => {
            expect(router).to.have.property('location')
              .that.is.an('object')
              .and.is.not.null;
          });

          it('should initially have non-null pathname, routes and params properties', () => {
            expect(router.location).to.have.property('pathname')
              .that.is.a('string');
            expect(router.location).to.have.property('routes')
              .that.is.deep.equal([]);
            expect(router.location).to.have.property('params')
              .that.is.deep.equal({});
          });

          it('should contain the pathname from the last completed render pass', async() => {
            router.setRoutes([
              {path: '/', component: 'x-root'},
              {path: '/a/b/c', component: 'x-a'}
            ]);

            await router.render('/');
            await router.render('/a/b/c');

            expect(router.location.pathname).to.equal('/a/b/c');
          });

          it('should contain the pathname from the last completed render pass (with params)', async() => {
            router.setRoutes([
              {path: '/a/b/:c', component: 'x-a'}
            ]);

            await router.render('/a/b/42');

            expect(router.location.pathname).to.equal('/a/b/42');
          });

          it('should contain the final and the original pathnames from the last completed render pass (redirected)', async() => {
            router.setRoutes([
              {path: '/a', redirect: '/c'},
              {path: '/c', component: 'x-a'}
            ]);

            await router.render('/a');

            expect(router.location.pathname).to.equal('/c');
            expect(router.location.redirectFrom).to.equal('/a');
          });

          it('should contain the pathname after a failed render', async() => {
            router.setRoutes([
              {path: '/a', component: 'x-a'}
            ]);

            await router.render('/a');
            await router.render('/non-existent-path').catch(() => {});

            expect(router.location.pathname).to.equal('/non-existent-path');
          });

          it('should contain the routes chain from the last completed render pass (single route)', async() => {
            const route = {path: '/', component: 'x-home-view'};
            router.setRoutes(route);

            await router.ready;

            expect(router.location.routes).to.have.lengthOf(1);
            expect(router.location.routes[0]).to.equal(route);
          });

          it('should contain the routes chain from the last completed render pass (multiple routes)', async() => {
            const routeC = {path: '/c', component: 'x-c'};
            const routeB = {path: '/b', component: 'x-b', children: [routeC]};
            const routeA = {path: '/a', component: 'x-a', children: [routeB]};

            router.setRoutes(routeA);
            await router.render('/a/b/c');

            expect(router.location.routes).to.have.lengthOf(3);
            expect(router.location.routes[0]).to.equal(routeA);
            expect(router.location.routes[1]).to.equal(routeB);
            expect(router.location.routes[2]).to.equal(routeC);
          });

          it('should contain an empty routes chain array after a failed render', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'}
            ]);
            await router.render('/');
            await router.render('/non-existent').catch(() => {});

            expect(router.location.routes).to.deep.equal([]);
          });

          it('should have a separate property for the last route of the routes chain', async() => {
            const routeC = {path: '/c', component: 'x-c'};
            const routeB = {path: '/b', component: 'x-b', children: [routeC]};
            const routeA = {path: '/a', component: 'x-a', children: [routeB]};

            router.setRoutes(routeA);
            await router.render('/a/b/c');

            expect(router.location.route).to.equal(routeC);
          });

          it('should have an `undefined` route property after a failed render', async() => {
            const routeC = {path: '/c', component: 'x-c'};
            const routeB = {path: '/b', component: 'x-b', children: [routeC]};
            const routeA = {path: '/a', component: 'x-a', children: [routeB]};

            router.setRoutes(routeA);
            await router.render('/a/b/c');
            await router.render('/non-existent').catch(() => {});

            expect(router.location.route).to.not.be.defined;
          });

          it('should contain the parameters from the last completed render pass', async() => {
            router.setRoutes([
              {path: '/a/:b', component: 'x-a'},
              {path: '/:a/:b', component: 'x-any'},
            ]);

            await router.render('/any/thing');
            await router.render('/a/42');

            expect(router.location.params).to.deep.equal({b: '42'});
          });

          it('should contain the parameters from the last completed render pass (redirected)', async() => {
            router.setRoutes([
              {path: '/a/:id', redirect: '/b/:id'},
              {path: '/b/:id', component: 'x-b'}
            ]);

            await router.render('/a/42');

            expect(router.location.params).to.deep.equal({id: '42'});
          });

          it('should contain an empty parameters set after a failed render', async() => {
            router.setRoutes([
              {path: '/a/:id', component: 'x-a'}
            ]);

            await router.render('/a/42');
            await router.render('/non-existent-path').catch(() => {});

            expect(router.location.params).to.deep.equal({});
          });
        });

        describe('navigation events', () => {
          let router;
          beforeEach(async() => {
            router = new Vaadin.Router(outlet);
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/admin', component: 'x-admin-view'},
            ]);
            await router.render('/');
          });

          afterEach(() => {
            router.unsubscribe();
          });

          it('should update the history state after navigation', async() => {
            window.dispatchEvent(new CustomEvent('vaadin-router-go', {detail: {pathname: '/admin'}}));
            await router.ready;
            expect(window.location.pathname).to.equal('/admin');
          });

          it('should trigger a popstate event after navigation', async() => {
            const onpopstate = sinon.spy();
            window.addEventListener('popstate', onpopstate);
            window.dispatchEvent(new CustomEvent('vaadin-router-go', {detail: {pathname: '/admin'}}));
            await router.ready;
            window.removeEventListener('popstate', onpopstate);
            expect(onpopstate).to.have.been.called.once;
          });

          it('should not trigger a popstate event after navigation if the pathname has not changed', async() => {
            const onpopstate = sinon.spy();
            window.addEventListener('popstate', onpopstate);
            window.dispatchEvent(new CustomEvent('vaadin-router-go', {detail: {pathname: '/'}}));
            await router.ready;
            window.removeEventListener('popstate', onpopstate);
            expect(onpopstate).to.not.have.been.called;
          });

          it('should fire navigate event only once per single pathname change', async() => {
            const navigateSpy = sinon.spy();
            window.addEventListener('vaadin-router-go', navigateSpy);
            const event = new CustomEvent('vaadin-router-go', {detail: {pathname: '/admin'}});
            window.dispatchEvent(event);
            await router.ready;
            expect(navigateSpy).to.be.calledOnce;
          });

          it('should automatically subscribe to navigation events when created', async() => {
            window.dispatchEvent(new CustomEvent('vaadin-router-go', {detail: {pathname: '/'}}));
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should unsubscribe from navigation events after an `unsubscribe()` method call', async() => {
            router.unsubscribe();
            window.dispatchEvent(new CustomEvent('vaadin-router-go', {detail: {pathname: '/admin'}}));
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should subscribe to navigation events after a `subscribe()` method call', async() => {
            router.unsubscribe();
            router.subscribe();
            window.dispatchEvent(new CustomEvent('vaadin-router-go', {detail: {pathname: '/'}}));
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should handle updates to the routes config as navigation triggers', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should use the POPSTATE navigation trigger by default', async() => {
            window.dispatchEvent(new PopStateEvent('popstate'));
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should use the CLICK navigation trigger by default', async() => {
            const link = document.getElementById('admin-anchor');
            link.click();
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-admin-view/i);
          });

          it('should expose a static Router.go() method for navigation', async() => {
            Vaadin.Router.go('/admin');
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-admin-view/i);
          });

          it('should trigger a `vaadin-router-go` event on the `window` when Router.go() is called', () => {
            const spy = sinon.spy();
            window.addEventListener('vaadin-router-go', spy);
            Vaadin.Router.go('');
            window.removeEventListener('vaadin-router-go', spy);
            expect(spy).to.have.been.called.once;
            expect(spy.args[0][0]).to.have.property('type', 'vaadin-router-go');
          });

          it('should pass the given pathname in the `detail.pathname` property of the triggered event when Router.go() is called', () => {
            const spy = sinon.spy();
            window.addEventListener('vaadin-router-go', spy);
            Vaadin.Router.go('/a');
            window.removeEventListener('vaadin-router-go', spy);
            expect(spy).to.have.been.called.once;
            expect(spy.args[0][0]).to.have.deep.property('detail.pathname', '/a');
          });
        });

        describe('route parameters', () => {
          let router;
          beforeEach(() => {
            router = new Vaadin.Router(outlet);
          });

          afterEach(() => {
            router.unsubscribe();
          });

          it('should bind named parameters to `location.params` property using string keys', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/:user', component: 'x-user-profile'}
            ]);
            router.render('/foo');
            await router.ready.then((outlet) => {
              const elem = outlet.children[0];
              expect(elem.location).to.be.object;
              expect(elem.location.params).to.be.object;
              expect(elem.location.params.user).to.equal('foo');
            });
          });

          it('should bind unnamed parameters to `location.params` property using numeric indexes', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/(user[s]?)/:id', component: 'x-users-view'},
            ]);
            router.render('/users/1');
            await router.ready.then((outlet) => {
              const elem = outlet.children[0];
              expect(elem.location).to.be.object;
              expect(elem.location.params).to.be.object;
              expect(elem.location.params[0]).to.equal('users');
            });
          });

          it('should bind named custom parameters to `location.params` property using string keys', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/image-:size(\\d+)px', component: 'x-image-view'},
            ]);
            router.render('/image-15px');
            await router.ready.then((outlet) => {
              const elem = outlet.children[0];
              expect(elem.location).to.be.object;
              expect(elem.location.params).to.be.object;
              expect(elem.location.params.size).to.equal('15');
            });
          });

          it('should bind named segments to the `location.params` property using string keys', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/kb/:path+/:id', component: 'x-knowledge-base'},
            ]);
            router.render('/kb/folder/nested/1');
            await router.ready.then((outlet) => {
              const elem = outlet.children[0];
              expect(elem.location).to.be.object;
              expect(elem.location.params).to.be.object;
              expect(elem.location.params.path).to.deep.equal(['folder', 'nested']);
              expect(elem.location.params.id).to.equal('1');
            });
          });

          it('should set the `location.pathname` property on the route component', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/admin', component: 'x-admin-view'},
              {path: '(.*)', component: 'x-not-found-view'},
            ]);
            await router.render('/non-existent/path');
            expect(outlet.children[0]).to.have.deep.property('location.pathname', '/non-existent/path');
          });

          it('should keep route parameters when redirecting to different route', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/users/:id', redirect: '/user/:id'},
              {path: '/user/:id', component: 'x-users-view'},
            ]);
            await router.render('/users/1');
            const elem = outlet.children[0];
            expect(elem.tagName).to.match(/x-users-view/i);
            expect(elem.location.params).to.be.object;
            expect(elem.location.params.id).to.equal('1');
          });

          it('should create new component instance for the same route with different parameters', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/users/:id', component: 'x-users-view'},
            ]);

            await router.render('/users/1');
            const elemOne = outlet.children[0];
            expect(elemOne.tagName).to.match(/x-users-view/i);
            expect(elemOne.location.params).to.be.object;
            expect(elemOne.location.params.id).to.equal('1');

            await router.render('/users/2');
            const elemTwo = outlet.children[0];
            expect(elemTwo.tagName).to.match(/x-users-view/i);
            expect(elemTwo).to.not.equal(elemOne);
            expect(elemTwo.location.params).to.be.object;
            expect(elemTwo.location.params.id).to.equal('2');
          });
        });

        describe('route object properties: order of execution', () => {
          const existingBundlePath = 'components/vaadin-router/demo/demo-elements/bundle-script.js';
          const removeBundle = () => {
            const bundleScript = document.head.querySelector('script[src="' + existingBundlePath + '"][async]');
            if (bundleScript) {
              bundleScript.parentNode.removeChild(bundleScript);
            }
            expect(getBundleScripts(existingBundlePath).length).to.equal(0);
          };

          // variable name and value that is set in global context in the bundle above
          const bundleVariableName = 'bundleScriptTestVariable';
          const bundleVariableValue = 'Hello from bundle script!';

          let router;
          beforeEach(() => {
            router = new Vaadin.Router(outlet);
          });

          it('should load bundle once, bundle should be executed', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view', bundle: existingBundlePath},
            ]);
            await router.render('/');
            expect(window[bundleVariableName]).to.equal(bundleVariableValue);
            expect(getBundleScripts(existingBundlePath).length).to.equal(1);
          });

          it('should support loading bundle in the long format', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view', bundle: {
                module: existingBundlePath,
                nomodule: existingBundlePath
              }},
            ]);
            await router.render('/');
            expect(window[bundleVariableName]).to.equal(bundleVariableValue);
            expect(getBundleScripts(existingBundlePath).length).to.equal(1);
          });

          it('action should be called with correct parameters', async() => {
            const action = sinon.spy();
            router.setRoutes([
              {path: '/', component: 'x-home-view', action: action}
            ]);

            await router.render('/');

            expect(action).to.have.been.called.once;
            expect(action.args[0].length).to.equal(2);

            const contextParam = action.args[0][0];
            expect(contextParam.pathname).to.equal('/');
            expect(contextParam.route.path).to.equal('/');
            expect(contextParam.route.component).to.equal('x-home-view');

            const commandsParam = action.args[0][1];
            expect(commandsParam.prevent).to.be.an('undefined');
            expect(commandsParam.redirect).to.be.a('function');
            expect(commandsParam.component).to.be.a('function');
          });

          it('action.this points to the route that defines action', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view', action: function(context) {
                expect(this.path).to.equal('/');
                expect(this.component).to.equal('x-home-view');
                expect(this).to.be.equal(context.route);
              }}
            ]);

            await router.render('/');

            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should throw on incorrect bundle path', async() => {
            const nonExistingPath = 'does-not-exist.js';
            router.setRoutes([
              {path: '/', component: 'x-home-view', bundle: nonExistingPath},
            ]);

            await expectException(router.render('/'), ['Bundle not found']);
            expect(getBundleScripts(nonExistingPath).length).to.equal(0);
          });

          it('action without return should be executed before bundle but allow the bundle to be loaded', async() => {
            let actionExecuted = false;
            router.setRoutes([
              {path: '/', component: 'x-home-view', bundle: existingBundlePath, action: () => {
                removeBundle();
                actionExecuted = true;
              }},
            ]);

            await router.render('/');

            expect(actionExecuted).to.equal(true);
            expect(getBundleScripts(existingBundlePath).length).to.equal(1);
          });

          it('action with return should be executed before bundle and stop it from loading', async() => {
            let actionExecuted = false;
            const removeBundleAndReturn = (context) => {
              const bundleScript = document.head.querySelector('script[src="' + existingBundlePath + '"][async]');
              if (bundleScript) {
                bundleScript.parentNode.removeChild(bundleScript);
              }
              actionExecuted = true;
              expect(getBundleScripts(existingBundlePath).length).to.equal(0);
              return context.next();
            };

            router.setRoutes([
              {path: '/', bundle: existingBundlePath, action: removeBundleAndReturn},
              {path: '/', component: 'x-home-view'},
            ]);

            await router.render('/');

            expect(actionExecuted).to.equal(true);
            expect(getBundleScripts(existingBundlePath).length).to.equal(0);
          });

          it('action without return should be executed before redirect and allow it to happen', async() => {
            let actionExecuted = false;

            router.setRoutes([
              {path: '/test', redirect: '/home', action: () => {
                actionExecuted = true;
              }},
              {path: '/home', component: 'x-home-view'},
            ]);

            await router.render('/test');

            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
            expect(actionExecuted).to.equal(true);
          });

          it('action with return should be executed before redirect and stop it from happening', async() => {
            let actionExecuted = false;

            router.setRoutes([
              {path: '/home', redirect: '/users', action: context => {
                actionExecuted = true;
                return context.next();
              }},
              {path: '/home', component: 'x-home-view'},
              {path: '/users', component: 'x-users-view'},
            ]);

            await router.render('/home');

            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
            expect(actionExecuted).to.equal(true);
          });

          it('action with return should be executed before children function and stop it from being executed', async() => {
            let actionExecuted = false;
            const children = sinon.spy();

            router.setRoutes([
              {path: '/home', children, action: (context, commands) => {
                actionExecuted = true;
                return commands.redirect('/users');
              }},
              {path: '/users', component: 'x-users-view'},
            ]);

            await router.render('/home');

            expect(outlet.children[0].tagName).to.match(/x-users-view/i);
            expect(actionExecuted).to.equal(true);
            expect(children).to.not.have.been.called;
          });

          it('action with incorrect return throws before redirect', async() => {
            await Promise.all([NaN, 0, false, '', 'thisIsAlsoIncorrect'].map(async(incorrectReturnValue) => {
              const router = new Vaadin.Router(outlet);
              const erroneousPath = '/error';
              let actionExecuted = false;
              router.setRoutes([
                {
                  path: erroneousPath, redirect: '/users', action: () => {
                    actionExecuted = true;
                    return incorrectReturnValue;
                  }
                },
                {path: '/users', component: 'x-users-view'},
              ]);

              await expectException(router.render(erroneousPath), [erroneousPath, incorrectReturnValue]);
              expect(actionExecuted).to.equal(true);
              router.unsubscribe();
            }));
          });

          it('action with return should be executed before component and stop it from loading', async() => {
            let actionExecuted = false;

            router.setRoutes([
              {path: '/', component: 'x-home-view', action: (context) => {
                actionExecuted = true;
                return context.next();
              }},
              {path: '/', component: 'x-users-view'},
            ]);

            await router.render('/');

            expect(actionExecuted).to.equal(true);
            expect(outlet.children[0].tagName).to.match(/x-users-view/i);
          });

          it('action can redirect by using the context method', async() => {
            router.setRoutes([
              {path: '/users/:id', action: (context, commands) => commands.redirect('/user/:id')},
              {path: '/user/:id', component: 'x-users-view'},
            ]);

            await router.render('/users/1');

            const elem = outlet.children[0];
            expect(elem.tagName).to.match(/x-users-view/i);
            expect(elem.location.params).to.be.object;
            expect(elem.location.params.id).to.equal('1');
          });

          it('action can render components by using the context method', async() => {
            router.setRoutes([
              {path: '/users/:id', action: (context, commands) => commands.component('x-users-view')},
            ]);

            await router.render('/users/1');

            const elem = outlet.children[0];
            expect(elem.tagName).to.match(/x-users-view/i);
            expect(elem.location.params).to.be.object;
            expect(elem.location.params.id).to.equal('1');
          });

          it('redirect should be executed before component and stop it from loading', async() => {
            router.setRoutes([
              {path: '/test', redirect: '/users', component: 'x-home-view'},
              {path: '/users', component: 'x-users-view'},
            ]);

            await router.render('/test');

            expect(outlet.children[0].tagName).to.match(/x-users-view/i);
          });

          it('redirect should be executed before bundle and stop it from loading', async() => {
            removeBundle();

            router.setRoutes([
              {path: '/test', redirect: '/users', bundle: existingBundlePath},
              {path: '/users', component: 'x-users-view'},
            ]);

            await router.render('/test');

            expect(outlet.children[0].tagName).to.match(/x-users-view/i);
            expect(getBundleScripts(existingBundlePath).length).to.equal(0);
          });

          it('redirect should be executed before children function', async() => {
            const children = sinon.spy();

            router.setRoutes([
              {path: '/home', children, redirect: '/users'},
              {path: '/users', component: 'x-users-view'},
            ]);

            await router.render('/home/1');

            expect(outlet.children[0].tagName).to.match(/x-users-view/i);
            expect(children).to.not.have.been.called;
          });

          it('bundle should be executed before children function', async() => {
            removeBundle();

            router.setRoutes([
              {path: '/test', bundle: existingBundlePath, children: () => {
                expect(getBundleScripts(existingBundlePath).length).to.equal(1);
                return {path: '/child', component: 'x-test-child-view'};
              }},
            ]);

            await router.render('/test/child');

            expect(outlet.children[0].tagName).to.match(/x-test-child-view/i);
            expect(getBundleScripts(existingBundlePath).length).to.equal(1);
          });

          it('context.redirect() should work when invoked without the `this` context', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/a', action: (context, commands) => commands.redirect('/')}
            ]);

            await router.render('/a');

            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('action with redirect has its context.redirectFrom and redirect.from populated correctly', async() => {
            const from = '/a/b/c';

            router.setRoutes([
              {path: '/a', children: [
                {path: '/b', children: [
                  {path: '/c', action: (context, commands) => {
                    const redirectObject = commands.redirect('/d');
                    expect(redirectObject.redirect.from).to.be.equal(from);
                    return redirectObject;
                  }}
                ]},
              ]},
              {path: '/d', component: 'x-home-view', action: context => {
                expect(context.redirectFrom).to.be.equal(from);
              }}
            ]);

            await router.render(from);

            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('action with redirect gets double slashes removed from its context.redirectFrom and redirect.from', async() => {
            let from = '';
            router.setRoutes([
              {path: '/', children: [
                {path: '', children: [
                  {path: '/c', action: (context, commands) => commands.redirect('/d')}
                ]},
              ]},
              {path: '/d', component: 'x-home-view', action: context => {
                from = context.redirectFrom;
              }}
            ]);

            await router.render('/c');

            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
            expect(from).to.be.equal('/c');
          });

          it('should match routes with trailing slashes', async() => {
            router.setRoutes([
              {path: '/', component: 'x-a'},
              {path: '/child', children: [
                {path: '/', component: 'x-b'},
                {path: '/page/', component: 'x-c'}
              ]},
            ]);

            await router.render('/');
            checkOutlet(['x-a']);

            await router.render('/child/');
            checkOutlet(['x-b']);

            await router.render('/child/page/');
            checkOutlet(['x-c']);
          });
        });

        describe('children (function)', () => {
          let router;
          beforeEach(() => {
            router = new Vaadin.Router(outlet);
          });

          it('should be able to return a list of routes', async() => {
            const children = () => [
              {path: '/:user', component: 'x-user-profile'}
            ];

            router.setRoutes([
              {path: '/users', children}
            ]);

            await router.render('/users/2');

            const elem = outlet.children[0];
            expect(elem.tagName).to.match(/x-user-profile/i);
            expect(elem.location.params).to.be.object;
            expect(elem.location.params.user).to.equal('2');
          });

          it('should be able to return a promise', async() => {
            const children = () => Promise.resolve([
              {path: '/:user', component: 'x-user-profile'}
            ]);

            router.setRoutes([
              {path: '/users', children}
            ]);

            await router.render('/users/2');

            const elem = outlet.children[0];
            expect(elem.tagName).to.match(/x-user-profile/i);
            expect(elem.location.params).to.be.object;
            expect(elem.location.params.user).to.equal('2');
          });

          it('should be able to override the route `children` property instead of returning a value', async() => {
            const children = sinon.spy((context) => {
              context.route.children = [
                {path: '/:user', component: 'x-user-profile'}
              ];
            });

            router.setRoutes([
              {path: '/users', children}
            ]);

            await router.render('/users/2');
            expect(outlet.children[0].tagName).to.match(/x-user-profile/i);

            await router.render('/users/2');
            expect(outlet.children[0].tagName).to.match(/x-user-profile/i);
            expect(children).to.have.been.called.once;
          });

          it('should be called every time when resolver needs the route children list', async() => {
            const children = sinon.spy(() => [
              {path: '/:user', component: 'x-user-profile'}
            ]);

            router.setRoutes([
              {path: '/users', children},
            ]);

            await router.render('/users/1');
            expect(outlet.children[0].tagName).to.match(/x-user-profile/i);

            await router.render('/users/1');
            expect(outlet.children[0].tagName).to.match(/x-user-profile/i);

            expect(children).to.have.been.calledTwice;
          });

          it('should throw if the return result is not an object or array', async() => {
            const children = () => new Promise(resolve => {
              resolve(null);
            });

            router.setRoutes([
              {path: '/users', children},
            ]);

            await expectException(router.render('/users/1'), ['Incorrect "children" value']);
          });

          it('should discard the previous return value and use the new one', async() => {
            let callCount = 0;
            const children = () => {
              return ++callCount === 1 ? [{path: '/:user', component: 'x-user-profile'}] : [];
            };

            router.setRoutes([
              {path: '/users', children},
              {path: '(.*)', component: 'x-not-found-view'},
            ]);

            await router.render('/users/1');
            expect(outlet.children[0].tagName).to.match(/x-user-profile/i);

            await router.render('/users/1');
            expect(outlet.children[0].tagName).to.match(/x-not-found-view/i);
          });

          it('should not be called when resolver does not need the route children list', async() => {
            const children = sinon.spy();
            router.setRoutes([
              {path: '/users', component: 'x-users-layout'},
              {path: '/', children}
            ]);
            await router.ready.catch(() => {});
            children.reset();

            await router.render('/users');

            expect(outlet.children[0].tagName).to.match(/x-users-layout/i);
            expect(children).to.not.have.been.called;
          });

          it('should be called with the resolver context as the only argument', async() => {
            const children = sinon.spy();
            router.setRoutes([
              {path: '/users', children}
            ]);

            await router.render('/users/1').catch(() => {});

            expect(children).to.have.been.called.once;
            expect(children.args[0].length).to.equal(1);

            const context = children.args[0][0];
            expect(context.pathname).to.equal('/users/1');
            expect(context.route.path).to.equal('/users');
            expect(context.next).to.be.an('undefined');
          });

          it('should be called on the route object (as `this`)', async() => {
            const children = sinon.spy();
            const route = {path: '/users', children};
            router.setRoutes([route]);

            await router.render('/users/1').catch(() => {});

            expect(children).to.have.been.calledOn(route);
          });

          it('should cause resolver to throw if the returned routes are invalid', async() => {
            const incorrectRoutes = [
              {},
              true,
              {redirect: {pathname: '/'}},
              () => false,
              new Promise(resolve => resolve(222)),
              2,
              'whatever',
              {component: 'i-have-no-path-property'},
            ];

            for (let i = 0; i < incorrectRoutes.length; i++) {
              router.setRoutes({path: '/a', children: () => incorrectRoutes[i]});

              let exceptionThrown = false;
              await router.render('/a').catch(() => {
                exceptionThrown = true;
              });

              expect(exceptionThrown, `No exception thrown for 'children' function incorrect return value '${incorrectRoutes[i]}'`)
                .to.equal(true);
            }
          });

          it('if the return value is a tree of nested routes, they should get resolved correctly', async() => {
            router.setRoutes([
              {
                path: '/',
                component: 'x-root',
                children: [{
                  path: '/a',
                  children: () => (
                    {
                      path: '/b',
                      children: () => new Promise(resolve => resolve(
                        {
                          path: '/c',
                          component: 'x-c',
                          children: [
                            {
                              path: '/d',
                              component: 'x-d'
                            }
                          ]
                        }
                      ))
                    }
                  )
                }]
              },
            ]);

            await router.render('/a/b/c/d');

            checkOutlet(['x-root', 'x-c', 'x-d']);
          });

          it('if the return value is route with a `redirect`, it should get resolved correctly', async() => {
            router.setRoutes(
              {
                path: '/a',
                children: () => [
                  {path: '/b', redirect: '/a/c', component: 'x-b'},
                  {path: '/c', component: 'x-c'}
                ]
              }
            );

            await router.render('/a/b');

            expect(outlet.children[0].tagName).to.match(/x-c/i);
          });
        });

        describe('animated transitions', () => {
          let router, observer, data = [];

          beforeEach(() => {
            router = new Vaadin.Router(outlet);
            observer = new window.MutationObserver(records => data = data.concat(records));
          });

          afterEach(() => {
            observer.disconnect();
            router.unsubscribe();
          });

          it('should set and then remove the CSS classes, if `animate` is set to true', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/animate', component: 'x-animate-view', animate: true}
            ]);

            await router.render('/');

            observer.observe(outlet, {
              subtree: true,
              attributes: true,
              attributeOldValue: true,
              attributeFilter: ['class']
            });

            await router.render('/animate');

            // FIXME(web-padawan): force IE11 to pick up mutations
            if (/Trident/.test(navigator.userAgent)) {
              data = observer.takeRecords();
            }

            expect(data.length).to.equal(4);
            expect(data[0].target.tagName).to.match(/x-home-view/i);
            expect(data[1].target.tagName).to.match(/x-home-view/i);
            expect(data[1].oldValue).to.equal('leaving');
            expect(data[2].target.tagName).to.match(/x-animate-view/i);
            expect(data[3].target.tagName).to.match(/x-animate-view/i);
            expect(data[3].oldValue).to.equal('entering');
          });
        });

        describe('vaadin-router-meta', () => {
          let router;

          beforeEach(() => {
            router = new Vaadin.Router(outlet);
          });

          afterEach(() => {
            router.unsubscribe();
          });

          it('should expose the version on the `vaadin-router-meta` custom element class', async() => {
            const meta = customElements.get('vaadin-router-meta');
            expect(meta).to.be.not.empty;
            expect(meta.version).to.be.string;
          });
        });
      });
    });

    function getBundleScripts(scriptPath) {
      return document.head.querySelectorAll('script[src="' + scriptPath + '"][async]');
    }

    async function expectException(callback, expectedContentsArray) {
      let exceptionThrown = false;
      try {
        await callback;
      } catch (e) {
        exceptionThrown = true;
        if (expectedContentsArray && expectedContentsArray.length) {
          const exceptionString = e.message || JSON.stringify(e);
          for (let i = 0; i < expectedContentsArray.length; i++) {
            expect(exceptionString).to.contain(expectedContentsArray[i]);
          }
        }
      }
      expect(exceptionThrown).to.equal(true);
    }
  </script>
</body>
