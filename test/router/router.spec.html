<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>router.spec</title>
  <script src="../../bower_components/web-component-tester/browser.js"></script>
  <script src="../../bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../dist/vaadin-router.umd.js"></script>
</head>

<body>
  <a id="admin-anchor" href="/admin"></a>
  <test-fixture id="outlet">
    <template>
      <div></div>
    </template>
  </test-fixture>

  <script>
    describe('Vaadin.Router', function() {
      // eslint-disable-next-line no-invalid-this
      this.title = this.title + (window.ShadyDOM ? ' (Shady DOM)' : '');

      var outlet;
      beforeEach(() => {
        // reset the URL
        window.history.pushState(null, null, '/');

        // stamp the test fixture DOM into the page
        outlet = fixture('outlet');
      });

      describe('JS API (basic functionality)', () => {
        describe('new Router(outlet?, options?)', () => {
          it('should work without arguments', () => {
            const router = new Vaadin.Router();
            expect(router).to.be.ok;
          });

          it('should accept a router outlet DOM Node as the 1st argument', () => {
            const router = new Vaadin.Router(outlet);
            const actual = router.getOutlet();
            expect(actual).to.equal(outlet);
          });

          it('should throw if the router outlet is truthy but is not valid a DOM Node', () => {
            [
              true,
              42,
              '<slot></slot>',
              {},
              [document.body],
              () => document.body
            ].forEach(arg => {
              expect(() => new Vaadin.Router(arg), `${arg}`).to.throw(TypeError);
            });
          });

          it('route should throw when created with unknown bundle type', () => {
            const router = new Vaadin.Router(outlet);
            expect(() => router.setRoutes([{path: '/', bundle: () => {}}])).to.throw(Error);
          });

          it('route should throw when created with unknown bundle extension', () => {
            const router = new Vaadin.Router(outlet);
            expect(() => router.setRoutes([{path: '/', bundle: 'test.html'}])).to.throw(Error);
          });

          it('should accept an options object as the 2nd argument', () => {
            const router = new Vaadin.Router(null, {baseUrl: '/users'});
            expect(router).to.have.property('baseUrl', '/users');
          });
        });

        describe('router.render(pathname)', () => {
          const add100msDelay = () => {
            return new Promise((resolve, reject) => {
              setTimeout(() => resolve(), 100);
            });
          };

          let router;
          beforeEach(() => {
            router = new Vaadin.Router(outlet);
          });

          afterEach(() => {
            router.unsubscribe();
          });

          it('should throw if the router outlet is not a valid DOM Node (on start)', () => {
            [
              undefined,
              null,
              0,
              false,
              '',
              NaN
            ].forEach(invalidOutlet => {
              router.setOutlet(invalidOutlet);
              expect(() => router.render('/'), `${invalidOutlet}`).to.throw(TypeError);
            });
          });

          it('should throw if the router outlet is a not valid DOM Node (on finish)', async() => {
            await Promise.all([
              undefined,
              null,
              0,
              false,
              '',
              NaN
            ].map(async(invalidOutlet) => {
              const router = new Vaadin.Router(outlet);
              router.setRoutes([{path: '/', component: 'x-home-view'}]);
              const fulfilled = sinon.spy();
              const rejected = sinon.spy();
              const ready = router.render('/').then(fulfilled).catch(rejected);
              router.setOutlet(invalidOutlet);
              await ready;
              expect(fulfilled).to.not.have.been.called;
              expect(rejected).to.have.been.called.once;
              expect(rejected.args[0][0]).to.be.instanceof(TypeError);
              router.unsubscribe();
            }));
          });

          it('should return a promise that resolves to the router outlet DOM element', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            const result = router.render('/');
            expect(result).to.be.a('promise');
            const actual = await result;
            expect(actual).to.equal(outlet);
          });

          it('should return a promise that resolves when the rendered content is appended to the DOM', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            const promise = router.render('/');
            expect(outlet.children).to.have.lengthOf(0);
            await promise;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should return a promise that gets rejected on no-match', (done) => {
            const result = router.render('/path/not/defined');
            result
              .then(() => {
                throw new Error('the promise should have been rejected');
              })
              .catch(() => done());
          });

          it('should create and append a route `component` into the router outlet', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            await router.render('/');
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should rethrow DOMException if the route `component` is not a valid tag name', async() => {
            router.setRoutes([{path: '/', component: 'src/x-home-view'}]);
            const fulfilled = sinon.spy();
            const rejected = sinon.spy();
            const ready = router.render('/').then(fulfilled).catch(rejected);
            await ready;
            expect(fulfilled).to.not.have.been.called;
            expect(rejected).to.have.been.called.once;
            expect(rejected.args[0][0]).to.be.instanceof(DOMException);
          });

          it('should replace any pre-existing content of the router outlet', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/users', component: 'x-users-view'},
            ]);
            await router.render('/');
            await router.render('/users');
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-users-view/i);
          });

          it('should remove any pre-existing content of the router outlet on no-match', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            await router.render('/');

            await router.render('/path/not/defined').catch(() => {});
            expect(outlet.children).to.have.lengthOf(0);
          });

          it('should ignore a successful result of a resolve pass if a new resolve pass is started before the first is completed', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/slow', action: add100msDelay, children: [
                {path: '/users', component: 'x-users-view'},
              ]},
              {path: '/admin', component: 'x-admin-view'},
            ]);
            await Promise.all([
              router.render('/slow/users'), // start the first resolve pass
              router.render('/admin'), // start the second resolve pass before the first is completed
            ]);
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-admin-view/i);
          });

          it('should ignore an error result of a resolve pass if a new resolve pass is started before the first is completed', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/slow', action: add100msDelay, children: [
                {path: '/users', component: 'x-users-view'},
              ]},
              {path: '/admin', component: 'x-admin-view'},
            ]);
            await Promise.all([
              router.render('/slow/non-existent').catch(() => {}), // start the first resolve pass
              router.render('/admin'), // start the second resolve pass before the first is completed
            ]);
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-admin-view/i);
          });

          it('should start a new resolve pass when route has "redirect" property', async() => {
            const from = '/people';
            const pathname = '/users';
            const result = {redirect: {pathname, from, params: {}}};

            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/people', redirect: '/users'},
              {path: '/users', component: 'x-users-view'},
            ]);
            const spy = sinon.spy(router, 'resolve');
            await router.render(from);

            expect(spy).to.be.calledTwice;
            const firstResult = await spy.returnValues[0];
            expect(firstResult).to.deep.equal(result);

            expect(spy.secondCall.args[0].from).to.equal(from);
            expect(spy.secondCall.args[0].pathname).to.equal(pathname);
          });

          it('should render a component for the new route when redirecting', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/people', redirect: '/users'},
              {path: '/users', component: 'x-users-view'},
            ]);
            await router.render('/people');
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-users-view/i);
          });

          it('should set the `route.redirectFrom` property on the route component in case of redirect', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/people', redirect: '/users'},
              {path: '/users', component: 'x-users-view'},
            ]);
            await router.render('/people');
            expect(outlet.children[0]).to.have.deep.property('route.redirectFrom', '/people');
          });
        });

        describe('router.ready', () => {
          let router;
          beforeEach(() => {
            router = new Vaadin.Router(outlet);
          });

          afterEach(() => {
            router.unsubscribe();
          });

          it('should be a promise', () => {
            expect(router).to.have.property('ready')
              .that.is.a('promise');
          });

          it('(render in progress / ok) should get fulfilled after the render is completed', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            router.render('/');
            await router.ready.then((outlet) => {
              expect(outlet.children).to.have.lengthOf(1);
              expect(outlet.children[0].tagName).to.match(/x-home-view/i);
            });
          });

          it('(render in progress / error) should get rejected with the current render error', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            router.render('non-existent-path');
            await router.ready.then(() => {
              throw new Error('the `ready` promise should have been rejected');
            }).catch((error) => {
              expect(outlet.children).to.have.lengthOf(0);
              expect(error).to.be.an('error');
              expect(error).to.have.property('code', 404);
              expect(error).to.have.property('message')
                .that.matches(/non-existent-path/);
            });
          });

          it('(render completed / ok) should get fulfilled with the last render result', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            await router.render('/').then(() => {
              return router.ready.then((outlet) => {
                expect(outlet.children).to.have.lengthOf(1);
                expect(outlet.children[0].tagName).to.match(/x-home-view/i);
              });
            });
          });

          it('(render completed / error) should get rejected with the last render error', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            await router.render('non-existent-path').catch(() => {
              return router.ready.then((outlet) => {
                throw new Error('the `ready` promise should have been rejected');
              }).catch((error) => {
                expect(error).to.be.an('error');
                expect(error).to.have.property('code', 404);
                expect(error).to.have.property('message')
                  .that.matches(/non-existent-path/);
              });
            });
          });

          it('(no renders yet) should get fulfilled before the first render completes', async() => {
            const sequence = [];
            const p1 = router.ready.then(() => {
              expect(outlet.children).to.have.lengthOf(0);
              sequence.push('no render yet');
            });

            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            const p2 = router.render('/').then(() => {
              expect(outlet.children).to.have.lengthOf(1);
              sequence.push('first render done');
            });

            await Promise.all([p1, p2]).then(() => {
              expect(sequence[0]).to.equal('no render yet');
              expect(sequence[1]).to.equal('first render done');
            });
          });
        });

        describe('navigation events', () => {
          let router;
          beforeEach(async() => {
            router = new Vaadin.Router(outlet);
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/admin', component: 'x-admin-view'},
            ]);
            await router.render('/');
          });

          afterEach(() => {
            router.unsubscribe();
          });

          it('should update the history state after navigation', async() => {
            window.dispatchEvent(new CustomEvent('vaadin-router:navigate', {detail: {pathname: '/admin'}}));
            await router.ready;
            expect(window.location.pathname).to.equal('/admin');
          });

          it('should trigger a popstate event after navigation', async() => {
            const onpopstate = sinon.spy();
            window.addEventListener('popstate', onpopstate);
            window.dispatchEvent(new CustomEvent('vaadin-router:navigate', {detail: {pathname: '/admin'}}));
            await router.ready;
            window.removeEventListener('popstate', onpopstate);
            expect(onpopstate).to.have.been.called.once;
          });

          it('should not trigger a popstate event after navigation if the pathname has not changed', async() => {
            const onpopstate = sinon.spy();
            window.addEventListener('popstate', onpopstate);
            window.dispatchEvent(new CustomEvent('vaadin-router:navigate', {detail: {pathname: '/'}}));
            await router.ready;
            window.removeEventListener('popstate', onpopstate);
            expect(onpopstate).to.not.have.been.called;
          });

          it('should fire navigate event only once per single pathname change', async() => {
            const navigateSpy = sinon.spy();
            window.addEventListener('vaadin-router:navigate', navigateSpy);
            const event = new CustomEvent('vaadin-router:navigate', {detail: {pathname: '/admin'}});
            window.dispatchEvent(event);
            await router.ready;
            expect(navigateSpy).to.be.calledOnce;
          });

          it('should automatically subscribe to navigation events when created', async() => {
            window.dispatchEvent(new CustomEvent('vaadin-router:navigate', {detail: {pathname: '/'}}));
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should unsubscribe from navigation events after an `unsubscribe()` method call', async() => {
            router.unsubscribe();
            window.dispatchEvent(new CustomEvent('vaadin-router:navigate', {detail: {pathname: '/admin'}}));
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should subscribe to navigation events after a `subscribe()` method call', async() => {
            router.unsubscribe();
            router.subscribe();
            window.dispatchEvent(new CustomEvent('vaadin-router:navigate', {detail: {pathname: '/'}}));
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should handle updates to the routes config as navigation triggers', async() => {
            router.setRoutes([{path: '/', component: 'x-home-view'}]);
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should ignore navigation events if no routes are set', async() => {
            router.setRoutes([]);
            await router.ready;

            window.dispatchEvent(new CustomEvent('vaadin-router:navigate', {detail: {pathname: '/'}}));
            const fulfilled = sinon.spy();
            const rejected = sinon.spy();
            await router.ready.then(fulfilled).catch(rejected);
            expect(rejected).to.not.have.been.called;
          });

          it('should use the POPSTATE navigation trigger by default', async() => {
            window.dispatchEvent(new PopStateEvent('popstate'));
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          });

          it('should use the CLICK navigation trigger by default', async() => {
            const link = document.getElementById('admin-anchor');
            link.click();
            await router.ready;
            expect(outlet.children).to.have.lengthOf(1);
            expect(outlet.children[0].tagName).to.match(/x-admin-view/i);
          });
        });

        describe('route parameters', () => {
          const existingBundlePath = 'components/vaadin-router/demo/demo-elements/bundle-script.js';
          // variable name and value that is set in global context in the bundle above
          const bundleVariableName = 'bundleScriptTestVariable';
          const bundleVariableValue = 'Hello from bundle script!';

          let router;
          beforeEach(() => {
            router = new Vaadin.Router(outlet);
          });

          afterEach(() => {
            router.unsubscribe();
          });

          it('should bind named parameters to `route.params` property using string keys', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/:user', component: 'x-user-profile'}
            ]);
            router.render('/foo');
            await router.ready.then((outlet) => {
              const elem = outlet.children[0];
              expect(elem.route).to.be.object;
              expect(elem.route.params).to.be.object;
              expect(elem.route.params.user).to.equal('foo');
            });
          });

          it('should bind unnamed parameters to `route.params` property using numeric indexes', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/(user[s]?)/:id', component: 'x-users-view'},
            ]);
            router.render('/users/1');
            await router.ready.then((outlet) => {
              const elem = outlet.children[0];
              expect(elem.route).to.be.object;
              expect(elem.route.params).to.be.object;
              expect(elem.route.params[0]).to.equal('users');
            });
          });

          it('should bind named custom parameters to `route.params` property using string keys', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/image-:size(\\d+)px', component: 'x-image-view'},
            ]);
            router.render('/image-15px');
            await router.ready.then((outlet) => {
              const elem = outlet.children[0];
              expect(elem.route).to.be.object;
              expect(elem.route.params).to.be.object;
              expect(elem.route.params.size).to.equal('15');
            });
          });

          it('should bind named segments to the `route.params` property using string keys', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/kb/:path+/:id', component: 'x-knowledge-base'},
            ]);
            router.render('/kb/folder/nested/1');
            await router.ready.then((outlet) => {
              const elem = outlet.children[0];
              expect(elem.route).to.be.object;
              expect(elem.route.params).to.be.object;
              expect(elem.route.params.path).to.deep.equal(['folder', 'nested']);
              expect(elem.route.params.id).to.equal('1');
            });
          });

          it('should set the `route.pathname` property on the route component', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/admin', component: 'x-admin-view'},
              {path: '(.*)', component: 'x-not-found-view'},
            ]);
            await router.render('/non-existent/path');
            expect(outlet.children[0]).to.have.deep.property('route.pathname', '/non-existent/path');
          });

          it('should keep route parameters when redirecting to different route', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view'},
              {path: '/users/:id', redirect: '/user/:id'},
              {path: '/user/:id', component: 'x-users-view'},
            ]);
            await router.render('/users/1');
            const elem = outlet.children[0];
            expect(elem.tagName).to.match(/x-users-view/i);
            expect(elem.route.params).to.be.object;
            expect(elem.route.params.id).to.equal('1');
          });

          it('should load bundle once, bundle should be executed', async() => {
            router.setRoutes([
              {path: '/', component: 'x-home-view', bundle: existingBundlePath},
            ]);
            await router.render('/');
            expect(window[bundleVariableName]).to.equal(bundleVariableValue);
            expect(getBundleScripts(existingBundlePath).length).to.equal(1);
          });

          it('should throw on incorrect bundle path', async() => {
            const nonExistingPath = 'does-not-exist.js';
            router.setRoutes([
              {path: '/', component: 'x-home-view', bundle: nonExistingPath},
            ]);

            await expectException(router.render('/'));
            expect(getBundleScripts(nonExistingPath).length).to.equal(0);
          });

          it('action without return should be executed before bundle but allow the bundle to be loaded', async() => {
            let actionExecuted = false;
            const removeBundle = () => {
              const bundleScript = document.head.querySelector('script[src="' + existingBundlePath + '"][async]');
              if (bundleScript) {
                bundleScript.parentNode.removeChild(bundleScript);
              }
              actionExecuted = true;
              expect(getBundleScripts(existingBundlePath).length).to.equal(0);
            };
            router.setRoutes([
              {path: '/', component: 'x-home-view', bundle: existingBundlePath, action: removeBundle},
            ]);

            await router.render('/');

            expect(actionExecuted).to.equal(true);
            expect(getBundleScripts(existingBundlePath).length).to.equal(1);
          });

          it('action with return should be executed before bundle and stop it from loading', async() => {
            let actionExecuted = false;
            const removeBundleAndReturn = (context) => {
              const bundleScript = document.head.querySelector('script[src="' + existingBundlePath + '"][async]');
              if (bundleScript) {
                bundleScript.parentNode.removeChild(bundleScript);
              }
              actionExecuted = true;
              expect(getBundleScripts(existingBundlePath).length).to.equal(0);
              return context.next();
            };

            router.setRoutes([
              {path: '/', bundle: existingBundlePath, action: removeBundleAndReturn},
              {path: '/', component: 'x-home-view'},
            ]);

            await router.render('/');

            expect(actionExecuted).to.equal(true);
            expect(getBundleScripts(existingBundlePath).length).to.equal(0);
          });

          it('action without return should be executed before redirect and allow it to happen', async() => {
            let actionExecuted = false;

            router.setRoutes([
              {path: '/test', redirect: '/home', action: () => {
                actionExecuted = true;
              }},
              {path: '/home', component: 'x-home-view'},
            ]);

            await router.render('/test');

            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
            expect(actionExecuted).to.equal(true);
          });

          it('action with return should be executed before redirect and stop it from happening', async() => {
            let actionExecuted = false;

            router.setRoutes([
              {path: '/home', redirect: '/users', action: (context) => {
                actionExecuted = true;
                return context.next();
              }},
              {path: '/home', component: 'x-home-view'},
              {path: '/users', component: 'x-users-view'},
            ]);

            await router.render('/home');

            expect(outlet.children[0].tagName).to.match(/x-home-view/i);
            expect(actionExecuted).to.equal(true);
          });

          it('action with incorrect return throws before redirect', async() => {
            await Promise.all([NaN, 0, false, '', 'thisIsAlsoIncorrect'].map(async(incorrectReturnValue) => {
              const router = new Vaadin.Router(outlet);
              const erroneousPath = '/error';
              let actionExecuted = false;
              router.setRoutes([
                {
                  path: erroneousPath, redirect: '/users', action: () => {
                    actionExecuted = true;
                    return incorrectReturnValue;
                  }
                },
                {path: '/users', component: 'x-users-view'},
              ]);

              await expectException(router.render(erroneousPath), [erroneousPath, incorrectReturnValue]);
              expect(actionExecuted).to.equal(true);
              router.unsubscribe();
            }));
          });

          it('action with return should be executed before component and stop it from loading', async() => {
            let actionExecuted = false;

            router.setRoutes([
              {path: '/', component: 'x-home-view', action: (context) => {
                actionExecuted = true;
                return context.next();
              }},
              {path: '/', component: 'x-users-view'},
            ]);

            await router.render('/');

            expect(actionExecuted).to.equal(true);
            expect(outlet.children[0].tagName).to.match(/x-users-view/i);
          });

          it('redirect should be executed before bundle and stop it from loading', async() => {
            router.setRoutes([
              {path: '/test', redirect: '/users', component: 'x-home-view'},
              {path: '/users', component: 'x-users-view'},
            ]);

            await router.render('/test');

            expect(outlet.children[0].tagName).to.match(/x-users-view/i);
          });
        });
      });
    });

    function getBundleScripts(scriptPath) {
      return document.head.querySelectorAll('script[src="' + scriptPath + '"][async]');
    }

    async function expectException(callback, expectedContentsArray) {
      let exceptionThrown = false;
      try {
        await callback;
      } catch (e) {
        exceptionThrown = true;
        if (expectedContentsArray && expectedContentsArray.length) {
          const exceptionString = e.message || JSON.stringify(e);
          for (let i = 0; i < expectedContentsArray.length; i++) {
            expect(exceptionString).to.contain(expectedContentsArray[i]);
          }
        }
      }
      expect(exceptionThrown).to.equal(true);
    }
  </script>
</body>
