<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>router.spec</title>
  <script src="../../bower_components/web-component-tester/browser.js"></script>
  <script src="../../bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../dist/vaadin-router.umd.js"></script>

  <link rel="import" href="../test-pushstate-throttler.html">
</head>

<body>
  <test-pushstate-throttler id="throttler"></test-pushstate-throttler>
  <test-fixture id="outlet">
    <template>
      <div></div>
    </template>
  </test-fixture>

  <script>
    describe('Vaadin.Router', function() {
      // eslint-disable-next-line no-invalid-this
      this.title = this.title + (window.ShadyDOM ? ' (Shady DOM)' : '');

      var outlet;
      beforeEach(() => {
        // reset the URL
        window.history.pushState(null, null, '/');

        // stamp the test fixture DOM into the page
        outlet = fixture('outlet');
      });

      const throttler = document.querySelector('#throttler');
      afterEach(function() {
        const test = this; // eslint-disable-line no-invalid-this
        return throttler.throttle(test);
      });

      describe('active routes', () => {
        let router;
        beforeEach(() => {
          router = new Vaadin.Router(outlet);
        });

        afterEach(() => {
          router.unsubscribe();
        });

        it('paths without parameters should have each route activated', async() => {
          router.setRoutes([
            {path: '/a', children: [
              {path: '/b', children: [
                {path: '/c', component: 'x-home-view'}
              ]},
              {path: '/', component: 'x-home-view'},
            ]},
            {path: '/d', component: 'x-home-view'}
          ]);

          await router.render('/a/b/c');
          verifyActiveRoutes(router, ['/a', '/b', '/c']);

          await router.render('/d');
          verifyActiveRoutes(router, ['/d']);

          await router.render('/a');
          verifyActiveRoutes(router, ['/a', '/']);
        });

        it('paths with parameters should have each route activated without parameters replaced', async() => {
          router.setRoutes([
            {path: '/users/:user', component: 'x-user-profile'},
            {path: '/image-:size(\\d+)px', component: 'x-image-view'},
            {path: '/kb/:path+/:id', component: 'x-knowledge-base'},
          ]);

          await router.render('/users/1');
          verifyActiveRoutes(router, ['/users/:user']);

          await router.render('/image-15px');
          verifyActiveRoutes(router, ['/image-:size(\\d+)px']);

          await router.render('/kb/folder/nested/1');
          verifyActiveRoutes(router, ['/kb/:path+/:id']);
        });

        it('redirect overwrites activated routes', async() => {
          router.setRoutes([
            {path: '/a', children: [
              {path: '/b', children: [
                {path: '/c', component: 'x-home-view'}
              ]},
            ]},
            {path: '/', redirect: '/a/b/c'},
          ]);

          await router.render('/');

          verifyActiveRoutes(router, ['/a', '/b', '/c']);
        });

        it('action that returns an element does not add an extra active route', async() => {
          router.setRoutes([
            {path: '/', action: context => context.next()},
            {path: '/', component: 'x-home-view'},
          ]);

          await router.render('/');

          verifyActiveRoutes(router, ['/']);
        });

        it('action that returns an element overrides inactivate for the same route', async() => {
          const inactivate = sinon.spy();
          router.setRoutes([
            {path: '/', action: context => context.next(), inactivate: inactivate},
            {path: '/', component: 'x-home-view'},
            {path: '/b', component: 'x-users-view'},
          ]);

          await router.render('/');
          await router.render('/b');

          expect(inactivate).to.not.have.been.called;
        });

        it('action that returns custom component does not activate route', async() => {
          router.setRoutes([
            {path: '/', action: context => context.component('x-home-view')},
          ]);

          await router.render('/');

          verifyActiveRoutes(router, []);
        });

        it('action that returns redirect activates redirect route', async() => {
          router.setRoutes([
            {path: '/', action: context => context.redirect('/a')},
            {path: '/a', component: 'x-users-view'},
          ]);

          await router.render('/');

          verifyActiveRoutes(router, ['/a']);
          expect(outlet.children[0].tagName).to.match(/x-users-view/i);
        });

        it('inactivate is called on deactivation and does not interrupt render if returns no value', async() => {
          const inactivate = sinon.spy();
          router.setRoutes([
            {path: '/a', component: 'x-home-view', inactivate: inactivate},
            {path: '/b', component: 'x-users-view'},
          ]);

          await router.render('/a');
          expect(inactivate).to.not.have.been.called;

          await router.render('/b');
          expect(inactivate).to.have.been.called.once;
          expect(outlet.children[0].tagName).to.match(/x-users-view/i);
          verifyActiveRoutes(router, ['/b']);
        });

        it('inactivate chain is called in reversed order, from last route to first', async() => {
          const deactivatedPaths = [];
          router.setRoutes([
            {path: '/a', inactivate: function() {
              deactivatedPaths.push(this.path);
            }, children: [
              {path: '/b', inactivate: function() {
                deactivatedPaths.push(this.path);
              }, children: [
                {path: '/c', component: 'x-users-view', inactivate: function() {
                  deactivatedPaths.push(this.path);
                }},
              ]},
            ]},
            {path: '/', component: 'x-home-view'},
          ]);

          await router.render('/a/b/c');
          await router.render('/');
          expect(deactivatedPaths).to.deep.equal(['/c', '/b', '/a']);
        });

        it('inactivate is called with correct context argument', async() => {
          const lastResolvedRoute = '/b';
          const lastComponentToRender = 'x-users-view';
          const inactivateFunction = sinon.spy();
          router.setRoutes([
            {path: '/a', component: 'x-home-view', inactivate: inactivateFunction},
            {path: lastResolvedRoute, component: lastComponentToRender},
          ]);

          await router.render('/a');

          expect(inactivateFunction).to.not.have.been.called;

          await router.render(lastResolvedRoute);

          expect(inactivateFunction).to.have.been.called.once;
          expect(inactivateFunction.args[0].length).to.equal(1);
          const contextParam = inactivateFunction.args[0][0];
          expect(contextParam.pathname).to.equal(lastResolvedRoute);
          expect(contextParam.route.path).to.equal(lastResolvedRoute);
          expect(contextParam.route.component).to.equal(lastComponentToRender);
        });

        it('inactivate.this points to the route that defines action', async() => {
          router.setRoutes([
            {path: '/a', component: 'x-home-view', inactivate: function(context) {
              expect(this.path).to.equal('/a');
              expect(this.component).to.equal('x-home-view');
              expect(this).not.to.be.equal(context.route);
              expect(context.route.path).to.be.equal('/b');
              expect(context.route.component).to.be.equal('x-users-view');
            }},
            {path: '/b', component: 'x-users-view'},
          ]);

          await router.render('/a');
          await router.render('/b');

          expect(outlet.children[0].tagName).to.match(/x-users-view/i);
        });

        it('inactivate is not called for same routes in new resolve pass', async() => {
          const inactivateA = sinon.spy();
          const inactivateB = sinon.spy();
          const inactivateC = sinon.spy();

          router.setRoutes([
            {path: '/a', inactivate: inactivateA, children: [
              {path: '/b', inactivate: inactivateB, children: [
                {path: '/c', inactivate: inactivateC, component: 'x-home-view'}
              ]},
              {path: '/', component: 'x-home-view'},
            ]},
          ]);

          await router.render('/a/b/c');
          await router.render('/a');

          expect(inactivateA).to.not.have.been.called;
          expect(inactivateB).to.have.been.called.once;
          expect(inactivateC).to.have.been.called.once;
        });

        it('inactivate that returns cancel, changes render target and reverts active routes changes every time it is triggered', async() => {
          router.setRoutes([
            {path: '/a', children: [
              {path: '/b', inactivate: context => context.cancel(), children: [
                {path: '/c', component: 'x-home-view'}
              ]},
            ]},
            {path: '/d', component: 'whatever'}
          ]);

          await router.render('/a/b/c');
          await router.render('/d');
          expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          verifyActiveRoutes(router, ['/a', '/b', '/c']);

          await router.render('/d');
          expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          verifyActiveRoutes(router, ['/a', '/b', '/c']);
        });


        it('inactivate is called when new activation path has no different routes but is shorter', async() => {
          const inactivate = sinon.spy();
          const actionToEmulateShorterResolvePass = context => {
            if ((context.pathname.match(/\//g) || []).length < 2) {
              return context.next();
            }
          };
          router.setRoutes([
            {path: '/a', action: actionToEmulateShorterResolvePass, children: [
              {path: '/b', component: 'x-users-view', inactivate: inactivate},
            ]},
            {path: '/a', component: 'x-home-view'}
          ]);

          await router.render('/a/b');
          expect(outlet.children[0].tagName).to.match(/x-users-view/i);
          verifyActiveRoutes(router, ['/a', '/b']);
          expect(inactivate).to.not.have.been.called;

          await router.render('/a');
          expect(outlet.children[0].tagName).to.match(/x-home-view/i);
          verifyActiveRoutes(router, ['/a']);
          expect(inactivate).to.have.been.called.once;
        });

        it('inactivate that returns cancel, changes render target and reverts active routes changes ' +
          'when new activation path has no different routes but is shorter', async() => {
          const actionToEmulateShorterResolvePass = context => {
            if ((context.pathname.match(/\//g) || []).length < 2) {
              return context.next();
            }
          };
          router.setRoutes([
            {path: '/a', action: actionToEmulateShorterResolvePass, children: [
              {path: '/b', component: 'x-users-view', inactivate: context => context.cancel()},
            ]},
            {path: '/a', component: 'whatever'}
          ]);

          await router.render('/a/b');
          await router.render('/a');

          expect(outlet.children[0].tagName).to.match(/x-users-view/i);
          verifyActiveRoutes(router, ['/a', '/b']);
        });
      });

      describe('redirect.from and context.from values for dynamic redirects', () => {
        let router;
        beforeEach(() => {
          router = new Vaadin.Router(outlet);
        });

        afterEach(() => {
          router.unsubscribe();
        });

        const from = '/a/b/c';
        const redirectFunction = context => {
          const redirectObject = context.redirect('/d');
          expect(redirectObject.redirect.from).to.be.equal(from);
          return redirectObject;
        };
        const verificationAction = context => {
          expect(context.from).to.be.equal(from);
        };

        it('action with redirect has its context.from and redirect.from populated correctly', async() => {
          router.setRoutes([
            {path: '/a', children: [
              {path: '/b', children: [
                {path: '/c', action: redirectFunction}
              ]},
            ]},
            {path: '/d', component: 'x-home-view', action: verificationAction}
          ]);

          await router.render(from);

          expect(outlet.children[0].tagName).to.match(/x-home-view/i);
        });
      });
    });

    function verifyActiveRoutes(router, expectedSegments) {
      expect(router.__activeRoutes.map(route => route.path)).to.deep.equal(expectedSegments);
    }
  </script>
</body>
